#!/bin/bash
# e2e_test.sh - End-to-end tests for large payload streaming
#
# Usage: ./e2e_test.sh [server_url] [api_key]
# Default server_url: http://localhost:8080
#
# Prerequisites:
# - Bifrost server running with /genai routes enabled
# - JSON payloads generated by generate_json_payloads.sh
# - Valid API key for Gemini
#
# This script verifies:
# 1. Functional correctness: requests succeed with HTTP 200
# 2. Code path verification: X-Bifrost-Large-Payload header confirms streaming path
# 3. Phase detection: X-Bifrost-Large-Payload-Phase header shows A or B
# 4. SSE format: response contains proper SSE data lines
# 5. Usage data: response contains usageMetadata

set -e

SERVER_URL="${1:-http://localhost:8080}"
API_KEY="${2:-$GEMINI_API_KEY}"
PAYLOAD_DIR="${3:-./json_payloads}"

if [ -z "$API_KEY" ]; then
    echo "Error: API key not provided. Set GEMINI_API_KEY or pass as second argument."
    exit 1
fi

echo "=== Large Payload E2E Test Suite ==="
echo "Server: $SERVER_URL"
echo "Payload directory: $PAYLOAD_DIR"
echo ""

GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

PASSED=0
FAILED=0
RESULTS_FILE=$(mktemp)

# Test helper function
# Args: test_name, payload_file, expected_status, check_streaming, expected_large_payload, expected_phase, endpoint
run_test() {
    local test_name="$1"
    local payload_file="$2"
    local expected_status="$3"
    local check_streaming="${4:-false}"
    local expected_large_payload="${5:-}"     # "true" or "" (empty = don't check)
    local expected_phase="${6:-}"             # "A", "B", or "" (empty = don't check)
    local endpoint="${7:-streamGenerateContent}"

    echo -ne "${YELLOW}[$test_name]${NC} "

    if [ ! -f "$payload_file" ]; then
        echo -e "${RED}SKIP${NC} - Payload file not found: $payload_file"
        return 0
    fi

    local url="$SERVER_URL/genai/v1beta/models/gemini-2.0-flash:$endpoint"
    if [ "$endpoint" = "streamGenerateContent" ]; then
        url="$url?alt=sse"
    fi

    local start_time=$(date +%s.%N)

    # Make request and capture response + headers
    local response_file=$(mktemp)
    local header_file=$(mktemp)
    local http_code=$(curl -s -w "%{http_code}" -o "$response_file" -D "$header_file" \
        -X POST "$url" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $API_KEY" \
        -d @"$payload_file" \
        --max-time 300)

    local end_time=$(date +%s.%N)
    local duration=$(echo "$end_time - $start_time" | bc)

    local payload_size=$(stat -f%z "$payload_file" 2>/dev/null || stat -c%s "$payload_file" 2>/dev/null)
    local payload_size_mb=$(echo "scale=2; $payload_size / 1048576" | bc)

    if [ "$http_code" = "$expected_status" ]; then
        echo -e "${GREEN}PASS${NC} (${duration}s, ${payload_size_mb}MB payload)"
        ((PASSED++))
        echo "PASS: $test_name" >> "$RESULTS_FILE"

        # === Code Path Verification ===
        if [ -n "$expected_large_payload" ]; then
            local lp_header=$(grep -i "X-Bifrost-Large-Payload:" "$header_file" 2>/dev/null | tr -d '\r' | awk '{print $2}')
            if [ "$lp_header" = "$expected_large_payload" ]; then
                echo -e "  - Large payload mode: ${GREEN}$lp_header (expected)${NC}"
            elif [ -z "$lp_header" ] && [ "$expected_large_payload" = "true" ]; then
                echo -e "  - Large payload mode: ${RED}NOT SET (expected 'true')${NC}"
                echo -e "    ${YELLOW}This means the streaming optimization is NOT active!${NC}"
                echo "WARN: $test_name - large payload header missing" >> "$RESULTS_FILE"
            elif [ -z "$lp_header" ]; then
                echo "  - Large payload mode: not set (small payload - correct)"
            else
                echo -e "  - Large payload mode: ${YELLOW}$lp_header (expected: $expected_large_payload)${NC}"
            fi
        fi

        # === Phase Verification ===
        if [ -n "$expected_phase" ]; then
            local phase_header=$(grep -i "X-Bifrost-Large-Payload-Phase:" "$header_file" 2>/dev/null | tr -d '\r' | awk '{print $2}')
            if [ "$phase_header" = "$expected_phase" ]; then
                echo -e "  - Phase: ${GREEN}$phase_header (expected)${NC}"
            elif [ -z "$phase_header" ]; then
                echo -e "  - Phase: ${RED}NOT SET (expected '$expected_phase')${NC}"
            else
                echo -e "  - Phase: ${YELLOW}$phase_header (expected: $expected_phase)${NC}"
            fi
        fi

        # === SSE Format Check ===
        if [ "$http_code" = "200" ] && [ "$check_streaming" = "true" ]; then
            if grep -q "^data: " "$response_file"; then
                echo "  - SSE streaming format: OK"
            else
                echo -e "  - ${YELLOW}Warning: No SSE data found in response${NC}"
            fi

            # Check for usage data in response
            if grep -qE "usageMetadata|\"usage\":|response\.completed" "$response_file"; then
                echo "  - Usage data present: OK"
            else
                echo -e "  - ${YELLOW}Warning: No usage data found${NC}"
            fi
        fi
    else
        echo -e "${RED}FAIL${NC} (expected $expected_status, got $http_code)"
        ((FAILED++))
        echo "FAIL: $test_name (expected $expected_status, got $http_code)" >> "$RESULTS_FILE"
        # Show error details
        head -c 500 "$response_file" 2>/dev/null || true
        echo ""
    fi

    rm -f "$response_file" "$header_file"
}

# Verify server is running
echo -e "${BLUE}--- Checking server availability ---${NC}"
if curl -s -o /dev/null -w "%{http_code}" "$SERVER_URL/health" | grep -q "200\|404"; then
    echo -e "${GREEN}Server is responding${NC}"
else
    echo -e "${RED}Error: Server not responding at $SERVER_URL${NC}"
    exit 1
fi
echo ""

# ═══════════════════════════════════════════════════════════════
# Test 1: Small Payload (should NOT trigger large payload mode)
# ═══════════════════════════════════════════════════════════════
echo -e "${BLUE}--- Test 1: Small Payload (Normal Path) ---${NC}"
echo "These should NOT trigger large payload mode"
echo "Expected: X-Bifrost-Large-Payload header should be ABSENT"
echo ""
#                 test_name                    payload                                     status stream large? phase
run_test "Small text request" "$PAYLOAD_DIR/small_text_phase_a.json" "200" "true" "" ""
echo ""

# ═══════════════════════════════════════════════════════════════
# Test 2: Phase A (Metadata at Start - fast path)
# ═══════════════════════════════════════════════════════════════
echo -e "${BLUE}--- Test 2: Phase A (Metadata at Start) ---${NC}"
echo "Large payloads with generationConfig BEFORE contents"
echo "Expected: X-Bifrost-Large-Payload: true, Phase: A"
echo ""
run_test "Phase A - AUDIO modality"       "$PAYLOAD_DIR/large_audio_phase_a.json"              "200" "true" "true" "A"
run_test "Phase A - IMAGE modality"       "$PAYLOAD_DIR/large_image_phase_a.json"              "200" "true" "true" "A"
run_test "Phase A - TEXT modality"        "$PAYLOAD_DIR/large_text_phase_a.json"               "200" "true" "true" "A"
run_test "Phase A - VIDEO input"          "$PAYLOAD_DIR/large_video_phase_a.json"              "200" "true" "true" "A"
run_test "Phase A - speechConfig only"    "$PAYLOAD_DIR/large_speech_config_only_phase_a.json" "200" "true" "true" "A"
echo ""

# ═══════════════════════════════════════════════════════════════
# Test 3: Phase B (Metadata at End - jstream fallback)
# ═══════════════════════════════════════════════════════════════
echo -e "${BLUE}--- Test 3: Phase B (Metadata at End) ---${NC}"
echo "Large payloads with contents BEFORE generationConfig"
echo "Expected: X-Bifrost-Large-Payload: true, Phase: B"
echo ""
run_test "Phase B - AUDIO modality"       "$PAYLOAD_DIR/large_audio_phase_b.json"              "200" "true" "true" "B"
run_test "Phase B - IMAGE modality"       "$PAYLOAD_DIR/large_image_phase_b.json"              "200" "true" "true" "B"
run_test "Phase B - TEXT modality"        "$PAYLOAD_DIR/large_text_phase_b.json"               "200" "true" "true" "B"
run_test "Phase B - VIDEO input"          "$PAYLOAD_DIR/large_video_phase_b.json"              "200" "true" "true" "B"
run_test "Phase B - speechConfig only"    "$PAYLOAD_DIR/large_speech_config_only_phase_b.json" "200" "true" "true" "B"
echo ""

# ═══════════════════════════════════════════════════════════════
# Test 4: Threshold Boundary
# ═══════════════════════════════════════════════════════════════
echo -e "${BLUE}--- Test 4: Threshold Boundary ---${NC}"
echo "Testing payloads around 10MB threshold"
echo ""
# below threshold = no large payload header; above threshold = large payload header
run_test "Just below threshold"           "$PAYLOAD_DIR/threshold_below.json"      "200" "true" "" ""
run_test "Just above threshold"           "$PAYLOAD_DIR/threshold_above.json"      "200" "true" "true" "A"
echo ""

# ═══════════════════════════════════════════════════════════════
# Test 5: No Metadata
# ═══════════════════════════════════════════════════════════════
echo -e "${BLUE}--- Test 5: No Metadata ---${NC}"
echo "Large payload without generationConfig"
echo "Expected: X-Bifrost-Large-Payload: true, Phase: B (fallback, no metadata found)"
echo ""
run_test "No metadata" "$PAYLOAD_DIR/large_no_metadata.json" "200" "true" "true" "B"
echo ""

# ═══════════════════════════════════════════════════════════════
# Results Summary
# ═══════════════════════════════════════════════════════════════
echo "=== E2E Test Results ==="
echo -e "Passed: ${GREEN}$PASSED${NC}"
echo -e "Failed: ${RED}$FAILED${NC}"
echo ""

# Check for warnings (large payload header missing when expected)
WARNINGS=$(grep "^WARN:" "$RESULTS_FILE" 2>/dev/null | wc -l | tr -d ' ')
if [ "$WARNINGS" -gt 0 ]; then
    echo -e "${YELLOW}Warnings ($WARNINGS):${NC}"
    grep "^WARN:" "$RESULTS_FILE"
    echo ""
    echo -e "${YELLOW}If large payload headers are missing, the streaming optimization${NC}"
    echo -e "${YELLOW}may not be active. Check that the code changes are applied.${NC}"
    echo ""
fi

if [ $FAILED -gt 0 ]; then
    echo "Failed tests:"
    grep "^FAIL:" "$RESULTS_FILE"
    rm -f "$RESULTS_FILE"
    exit 1
fi

rm -f "$RESULTS_FILE"
echo -e "${GREEN}All tests passed!${NC}"
