package plugins

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/maximhq/bifrost/core/schemas"
)

// LoadPlugins loads plugins based on the simplified configuration.
// Supports two types of plugins:
// 1. Local builds (for development) - requires binary_path
// 2. Go packages (for production) - requires package path, builds automatically
// Returns a slice of loaded plugins that can be used with Bifrost.
//
// Safety Features:
// - Checks for user-created 'cmd' directories in plugins to avoid overwriting custom code
// - Checks for user-created 'plugins' directory to avoid conflicts with existing binaries
// - Skips plugin loading if conflicts are detected and logs helpful suggestions
func LoadPlugins(pluginConfigs []PluginConfig) ([]schemas.Plugin, error) {
	var loadedPlugins []schemas.Plugin

	for _, config := range pluginConfigs {
		if !config.Enabled {
			log.Printf("Plugin %s is disabled, skipping", config.Name)
			continue
		}

		plugin, err := loadPlugin(config)
		if err != nil {
			// Check if this is a user-created cmd directory issue
			if strings.Contains(err.Error(), "user-created cmd directory") {
				log.Printf("error: plugin %s skipped due to user-created cmd directory conflict", config.Name)
				log.Printf("suggestion: either remove the custom cmd directory or set up the plugin manually without auto-generation")
			} else {
				log.Printf("warning: failed to load plugin %s: %v", config.Name, err)
			}
			continue
		}

		if plugin != nil {
			// Inject logger into the plugin
			if logger := getLoggerForPlugin(config.Name); logger != nil {
				plugin.SetLogger(logger)
			}

			log.Printf("Successfully loaded plugin: %s (source: %s)", config.Name, config.Source)
			loadedPlugins = append(loadedPlugins, plugin)
		}
	}

	return loadedPlugins, nil
}

// CleanupPluginDirectories cleans up auto-generated cmd directories and compiled binaries for all local plugins
// This should be called when the server shuts down to ensure a clean state
func CleanupPluginDirectories(pluginConfigs []PluginConfig) {
	for _, config := range pluginConfigs {
		if config.Source == PluginSourceLocal && config.PluginPath != "" {
			cmdDir := filepath.Join(config.PluginPath, "cmd")

			// Only cleanup if it's auto-generated
			if _, err := os.Stat(cmdDir); err == nil {
				if isAutoGeneratedCmdDirectory(cmdDir) {
					if err := cleanupCmdDirectory(cmdDir, config.Name); err != nil {
						log.Printf("warning: failed to cleanup cmd directory for plugin %s: %v", config.Name, err)
					}
				} else {
					log.Printf("info: skipping cleanup of user-created cmd directory for plugin %s", config.Name)
				}
			}

			// Also cleanup the compiled binary
			pluginsDir := "./plugins"
			binaryPath := filepath.Join(pluginsDir, config.Name+"-plugin")
			if _, err := os.Stat(binaryPath); err == nil {
				if err := os.Remove(binaryPath); err != nil {
					log.Printf("warning: failed to cleanup plugin binary %s: %v", binaryPath, err)
				} else {
					log.Printf("Cleaned up plugin binary: %s", binaryPath)
				}
			}
		}
	}

	// Remove the plugins directory if it only contains the marker file or is empty
	pluginsDir := "./plugins"
	if entries, err := os.ReadDir(pluginsDir); err == nil {
		// Check if directory only contains the marker file
		hasOnlyMarker := len(entries) == 1 && entries[0].Name() == ".bifrost-generated"
		isEmpty := len(entries) == 0

		if hasOnlyMarker || isEmpty {
			// Remove the entire directory
			if err := os.RemoveAll(pluginsDir); err != nil {
				log.Printf("warning: failed to remove plugins directory: %v", err)
			} else {
				log.Printf("Removed plugins directory")
			}
		}
	}
}

// loadPlugin loads a single plugin based on its simplified configuration
func loadPlugin(config PluginConfig) (schemas.Plugin, error) {
	switch config.Source {
	case PluginSourceLocal:
		return loadLocalPlugin(config)
	case PluginSourcePackage:
		return loadPackagePlugin(config)
	default:
		return nil, fmt.Errorf("unsupported plugin source: %s. Only 'local' and 'package' sources are supported", config.Source)
	}
}

// loadLocalPlugin loads a plugin from a local directory (for development)
func loadLocalPlugin(config PluginConfig) (schemas.Plugin, error) {
	if config.PluginPath == "" {
		return nil, fmt.Errorf("plugin_path is required for local source plugins")
	}

	// Build the plugin from the local directory
	builtBinaryPath, err := buildLocalPlugin(config)
	if err != nil {
		return nil, fmt.Errorf("failed to build local plugin from %s: %w", config.PluginPath, err)
	}

	// Set environment variables for the plugin
	if err := setPluginEnvironmentVariables(config); err != nil {
		return nil, err
	}

	// Load the built plugin
	plugin, err := LoadPlugin(builtBinaryPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load local plugin from %s: %w", config.PluginPath, err)
	}

	return plugin, nil
}

// buildLocalPlugin builds a plugin from a local directory
func buildLocalPlugin(config PluginConfig) (string, error) {
	// Validate plugin directory exists
	if _, err := os.Stat(config.PluginPath); os.IsNotExist(err) {
		return "", fmt.Errorf("plugin directory not found at path: %s", config.PluginPath)
	}

	// Check if the plugin implements the required interface
	if err := validateLocalPluginInterface(config.PluginPath); err != nil {
		return "", fmt.Errorf("plugin validation failed: %w", err)
	}

	// Auto-generate the RPC wrapper
	if err := generateLocalRPCWrapper(config); err != nil {
		return "", fmt.Errorf("failed to generate RPC wrapper: %w", err)
	}

	// Check and prepare plugins directory
	pluginsDir := "./plugins"
	if err := ensurePluginsDirectory(pluginsDir, config.Name); err != nil {
		return "", fmt.Errorf("failed to prepare plugins directory: %w", err)
	}

	// Get absolute path for output since we'll be running from cmdDir
	outputPath := filepath.Join(pluginsDir, config.Name+"-plugin")
	absOutputPath, err := filepath.Abs(outputPath)
	if err != nil {
		return "", fmt.Errorf("failed to get absolute path for output: %w", err)
	}

	cmdDir := filepath.Join(config.PluginPath, "cmd")

	// Build using go build
	cmd := exec.Command("go", "build", "-o", absOutputPath, ".")
	cmd.Dir = cmdDir
	cmd.Env = append(os.Environ(), "CGO_ENABLED=1")

	if output, err := cmd.CombinedOutput(); err != nil {
		return "", fmt.Errorf("failed to build local plugin: %w\nOutput: %s", err, string(output))
	}

	// Make executable
	if err := os.Chmod(absOutputPath, 0755); err != nil {
		return "", fmt.Errorf("failed to make plugin executable: %w", err)
	}

	log.Printf("Successfully built local plugin %s from %s", config.Name, config.PluginPath)
	return absOutputPath, nil
}

// validateLocalPluginInterface checks if a local plugin implements the required NewPlugin function
func validateLocalPluginInterface(pluginPath string) error {
	// Find all Go files in the plugin directory
	files, err := filepath.Glob(filepath.Join(pluginPath, "*.go"))
	if err != nil {
		return fmt.Errorf("failed to find Go files: %w", err)
	}

	if len(files) == 0 {
		return fmt.Errorf("no Go files found in plugin directory")
	}

	// Parse files to check for NewPlugin function (simplified check)
	for _, file := range files {
		if strings.HasSuffix(file, "_test.go") {
			continue // Skip test files
		}

		content, err := os.ReadFile(file)
		if err != nil {
			continue
		}

		// Simple text search for NewPlugin function
		if strings.Contains(string(content), "func NewPlugin(") {
			return nil
		}
	}

	return fmt.Errorf("plugin must implement 'func NewPlugin(json.RawMessage) (schemas.Plugin, error)'")
}

// generateLocalRPCWrapper creates the cmd/main.go file for a local plugin
func generateLocalRPCWrapper(config PluginConfig) error {
	cmdDir := filepath.Join(config.PluginPath, "cmd")

	// First check if cmd directory already exists and is user-created
	if _, err := os.Stat(cmdDir); err == nil {
		if !isAutoGeneratedCmdDirectory(cmdDir) {
			log.Printf("warning: plugin %s has a user-created cmd directory - will not overwrite user code", config.Name)
			log.Printf("suggestion: remove the custom cmd directory or set up the plugin manually without auto-generation")
			return fmt.Errorf("plugin %s has user-created cmd directory - cannot auto-generate RPC wrapper", config.Name)
		}
	}

	// Clean up any existing auto-generated cmd directory to ensure fresh state
	if err := cleanupCmdDirectory(cmdDir, config.Name); err != nil {
		return fmt.Errorf("failed to cleanup cmd directory: %w", err)
	}

	// Create fresh cmd directory
	if err := os.MkdirAll(cmdDir, 0755); err != nil {
		return fmt.Errorf("failed to create cmd directory: %w", err)
	}

	// Get the package name from the plugin directory
	packageName, err := parseLocalPackageInfo(config.PluginPath)
	if err != nil {
		return fmt.Errorf("failed to determine package name: %w", err)
	}

	// Generate module-aware import path
	importPath := fmt.Sprintf("github.com/maximhq/bifrost/plugins/%s", packageName)

	// Convert config to JSON string for embedding
	configJSON := "{}"
	if len(config.Config) > 0 {
		configJSON = string(config.Config)
	}

	// Template for local plugin RPC wrapper - using existing RPC implementation
	template := `// Auto-generated RPC wrapper for plugin: %s
// This file is generated by Bifrost plugin-loader
package main

import (
	"encoding/json"
	"log"

	"github.com/maximhq/bifrost/transports/bifrost-http/lib/plugins"
	pluginpkg "%s"
)

func main() {
	// Create plugin instance with actual configuration
	pluginInstance, err := pluginpkg.NewPlugin(json.RawMessage(%s))
	if err != nil {
		log.Fatalf("Failed to create plugin: %%v", err)
	}

	// Serve using the existing RPC implementation
	plugins.ServePlugin(pluginInstance)
}
`

	// Generate the RPC wrapper content
	content := fmt.Sprintf(template, config.Name, importPath, fmt.Sprintf("`%s`", configJSON))

	// Write to cmd/main.go
	mainGoPath := filepath.Join(cmdDir, "main.go")
	if err := os.WriteFile(mainGoPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write main.go: %w", err)
	}

	// Create go.mod file for the cmd directory
	if err := generateCmdGoMod(config, cmdDir, packageName); err != nil {
		return fmt.Errorf("failed to generate go.mod for cmd: %w", err)
	}

	return nil
}

// generateCmdGoMod creates a go.mod file for the cmd directory
func generateCmdGoMod(config PluginConfig, cmdDir, packageName string) error {
	goModTemplate := `module github.com/maximhq/bifrost/plugins/%s/cmd

go 1.21

require (
	github.com/maximhq/bifrost/plugins/%s v0.0.0
	github.com/hashicorp/go-plugin v1.6.3
	github.com/maximhq/bifrost/core v0.0.0
	github.com/maximhq/bifrost/transports v0.0.0
)

replace github.com/maximhq/bifrost/plugins/%s => ../
replace github.com/maximhq/bifrost/core => ../../../core
replace github.com/maximhq/bifrost/transports => ../../../transports
`

	content := fmt.Sprintf(goModTemplate, packageName, packageName, packageName)

	goModPath := filepath.Join(cmdDir, "go.mod")
	if err := os.WriteFile(goModPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write go.mod: %w", err)
	}

	// Run go mod tidy to resolve dependencies
	cmd := exec.Command("go", "mod", "tidy")
	cmd.Dir = cmdDir
	cmd.Env = os.Environ()

	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to run go mod tidy in cmd directory: %w\nOutput: %s", err, string(output))
	}

	return nil
}

// cleanupCmdDirectory removes the cmd directory if it exists
// This should only be called after confirming the directory is auto-generated
func cleanupCmdDirectory(cmdDir, pluginName string) error {
	if _, err := os.Stat(cmdDir); err == nil {
		log.Printf("Cleaning up existing auto-generated cmd directory for plugin %s", pluginName)
		if err := os.RemoveAll(cmdDir); err != nil {
			return fmt.Errorf("failed to remove existing cmd directory: %w", err)
		}
	}
	return nil
}

// isAutoGeneratedCmdDirectory checks if a cmd directory was auto-generated by looking for our markers
func isAutoGeneratedCmdDirectory(cmdDir string) bool {
	mainGoPath := filepath.Join(cmdDir, "main.go")

	// Check if main.go exists and contains our auto-generated marker
	if content, err := os.ReadFile(mainGoPath); err == nil {
		contentStr := string(content)
		// Look for our specific auto-generated markers
		return strings.Contains(contentStr, "// Auto-generated RPC wrapper for plugin:") &&
			strings.Contains(contentStr, "// This file is generated by Bifrost plugin-loader")
	}

	// If we can't read main.go or it doesn't have our markers, assume it's user-created
	return false
}

// ensurePluginsDirectory checks if plugins directory exists and handles user-created vs auto-generated scenarios
func ensurePluginsDirectory(pluginsDir, pluginName string) error {
	// Check if plugins directory already exists
	if _, err := os.Stat(pluginsDir); err == nil {
		if !isAutoGeneratedPluginsDirectory(pluginsDir) {
			log.Printf("warning: plugin %s skipped - user-created plugins directory exists", pluginName)
			log.Printf("suggestion: remove the custom plugins directory or manage plugin binaries manually")
			return fmt.Errorf("plugin %s skipped due to user-created plugins directory conflict", pluginName)
		}
	}

	// Create or ensure plugins directory exists
	if err := os.MkdirAll(pluginsDir, 0755); err != nil {
		return fmt.Errorf("failed to create plugins directory: %w", err)
	}

	// Create marker file to indicate this is auto-generated
	if err := createPluginsDirectoryMarker(pluginsDir); err != nil {
		log.Printf("warning: failed to create plugins directory marker: %v", err)
		// Don't fail here - this is just for tracking purposes
	}

	return nil
}

// isAutoGeneratedPluginsDirectory checks if a plugins directory was auto-generated by Bifrost
func isAutoGeneratedPluginsDirectory(pluginsDir string) bool {
	markerPath := filepath.Join(pluginsDir, ".bifrost-generated")

	// Check if marker file exists
	if _, err := os.Stat(markerPath); err == nil {
		return true
	}

	// If no marker file and directory is empty, consider it safe to use
	if entries, err := os.ReadDir(pluginsDir); err == nil && len(entries) == 0 {
		return true
	}

	// Check if all files in directory are plugin binaries (end with -plugin)
	if entries, err := os.ReadDir(pluginsDir); err == nil {
		for _, entry := range entries {
			if entry.IsDir() {
				return false // User-created if it contains directories
			}
			if !strings.HasSuffix(entry.Name(), "-plugin") && entry.Name() != ".bifrost-generated" {
				return false // User-created if it contains non-plugin files
			}
		}
		return true // All files are plugin binaries, likely auto-generated
	}

	// If we can't read the directory, assume it's user-created to be safe
	return false
}

// createPluginsDirectoryMarker creates a marker file to indicate the directory is auto-generated
func createPluginsDirectoryMarker(pluginsDir string) error {
	markerPath := filepath.Join(pluginsDir, ".bifrost-generated")
	markerContent := `# This file indicates that this plugins directory was auto-generated by Bifrost
# Do not remove this file unless you want to manage plugin binaries manually
# Generated by Bifrost plugin-loader system
`
	return os.WriteFile(markerPath, []byte(markerContent), 0644)
}

// parseLocalPackageInfo extracts the package name from a local Go package directory
func parseLocalPackageInfo(pluginPath string) (string, error) {
	// Find all Go files in the plugin directory
	files, err := filepath.Glob(filepath.Join(pluginPath, "*.go"))
	if err != nil {
		return "", err
	}

	if len(files) == 0 {
		return "", fmt.Errorf("no Go files found in plugin directory")
	}

	// Read the first non-test Go file to get the package name
	for _, file := range files {
		if strings.HasSuffix(file, "_test.go") {
			continue
		}

		content, err := os.ReadFile(file)
		if err != nil {
			continue
		}

		lines := strings.Split(string(content), "\n")
		for _, line := range lines {
			line = strings.TrimSpace(line)
			if strings.HasPrefix(line, "package ") {
				parts := strings.Fields(line)
				if len(parts) >= 2 {
					return parts[1], nil
				}
			}
		}
	}

	return "", fmt.Errorf("could not determine package name")
}

// loadPackagePlugin loads a plugin from a Go package (for production)
func loadPackagePlugin(config PluginConfig) (schemas.Plugin, error) {
	if config.Package == "" {
		return nil, fmt.Errorf("package is required for package source plugins")
	}

	// Build the plugin from the Go package
	builtBinaryPath, err := buildPluginFromPackage(config)
	if err != nil {
		return nil, fmt.Errorf("failed to build plugin from package %s: %w", config.Package, err)
	}

	// Set environment variables for the plugin
	if err := setPluginEnvironmentVariables(config); err != nil {
		return nil, err
	}

	// Load the built plugin
	plugin, err := LoadPlugin(builtBinaryPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load package plugin %s: %w", config.Package, err)
	}

	return plugin, nil
}

// buildPluginFromPackage builds a plugin from a Go package and returns the binary path
func buildPluginFromPackage(config PluginConfig) (string, error) {
	// Check and prepare plugins directory
	pluginsDir := "./plugins"
	if err := ensurePluginsDirectory(pluginsDir, config.Name); err != nil {
		return "", fmt.Errorf("failed to prepare plugins directory: %w", err)
	}

	// Create a temporary directory for building
	tempDir, err := os.MkdirTemp("", "plugin-build-"+config.Name)
	if err != nil {
		return "", fmt.Errorf("failed to create temp directory: %w", err)
	}
	defer os.RemoveAll(tempDir)

	// Generate main.go for the plugin
	mainContent := generatePackagePluginMain(config)
	mainPath := filepath.Join(tempDir, "main.go")
	if err := os.WriteFile(mainPath, []byte(mainContent), 0644); err != nil {
		return "", fmt.Errorf("failed to write main.go: %w", err)
	}

	// Generate go.mod for the plugin
	goModContent := generatePackagePluginGoMod(config)
	goModPath := filepath.Join(tempDir, "go.mod")
	if err := os.WriteFile(goModPath, []byte(goModContent), 0644); err != nil {
		return "", fmt.Errorf("failed to write go.mod: %w", err)
	}

	// Final binary path
	finalBinaryPath := filepath.Join(pluginsDir, config.Name+"-plugin")
	absOutputPath, err := filepath.Abs(finalBinaryPath)
	if err != nil {
		return "", fmt.Errorf("failed to get absolute path for output: %w", err)
	}

	// Build the plugin
	cmd := exec.Command("go", "build", "-o", absOutputPath, ".")
	cmd.Dir = tempDir
	cmd.Env = append(os.Environ(), "CGO_ENABLED=1")

	if output, err := cmd.CombinedOutput(); err != nil {
		return "", fmt.Errorf("failed to build package plugin: %w\nOutput: %s", err, string(output))
	}

	// Make executable
	if err := os.Chmod(absOutputPath, 0755); err != nil {
		return "", fmt.Errorf("failed to make plugin executable: %w", err)
	}

	log.Printf("Successfully built plugin %s from package %s", config.Name, config.Package)
	return absOutputPath, nil
}

// generatePackagePluginMain generates the main.go content for a package plugin
func generatePackagePluginMain(config PluginConfig) string {
	return fmt.Sprintf(`package main

import (
	"encoding/json"
	"log"

	"github.com/maximhq/bifrost/transports/bifrost-http/lib/plugins"
	pluginpkg "%s"
)

func main() {
	// Create plugin instance
	pluginInstance, err := pluginpkg.NewPlugin(json.RawMessage("{}"))
	if err != nil {
		log.Fatalf("Failed to create plugin: %%v", err)
	}

	// Serve using the existing RPC implementation
	plugins.ServePlugin(pluginInstance)
}
`, config.Package)
}

// generatePackagePluginGoMod generates the go.mod content for a package plugin
func generatePackagePluginGoMod(config PluginConfig) string {
	return fmt.Sprintf(`module plugin-%s

go 1.21

require (
	github.com/hashicorp/go-plugin v1.6.3
	github.com/maximhq/bifrost/core v1.1.4
	github.com/maximhq/bifrost/transports v0.0.0
	%s v0.0.0
)

replace %s => %s
replace github.com/maximhq/bifrost/transports => ../../transports

require (
	github.com/fatih/color v1.17.0 // indirect
	github.com/golang/protobuf v1.5.4 // indirect
	github.com/hashicorp/go-hclog v1.6.3 // indirect
	github.com/hashicorp/yamux v0.1.2 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mitchellh/go-testing-interface v1.14.1 // indirect
	github.com/oklog/run v1.1.0 // indirect
	golang.org/x/net v0.29.0 // indirect
	golang.org/x/sys v0.25.0 // indirect
	golang.org/x/text v0.18.0 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20240903143218-8af14fe29dc1 // indirect
	google.golang.org/grpc v1.66.2 // indirect
	google.golang.org/protobuf v1.34.2 // indirect
)
`, config.Name, config.Package, config.Package, determinePackagePath(config.Package))
}

// determinePackagePath determines the local path for a package
func determinePackagePath(packageName string) string {
	// For local development, assume packages are in the same workspace
	// This is a simple heuristic - in production you might want more sophisticated logic
	if strings.HasPrefix(packageName, "github.com/maximhq/bifrost/") {
		// Handle local bifrost plugins
		return "../../../" + strings.TrimPrefix(packageName, "github.com/maximhq/bifrost/")
	}
	// For external packages, don't use replace directive - let go mod download them
	return packageName
}

// setPluginEnvironmentVariables sets environment variables for the plugin
func setPluginEnvironmentVariables(config PluginConfig) error {
	for key, value := range config.EnvVars {
		// Handle environment variable placeholders
		if strings.HasPrefix(value, "env.") {
			envKey := strings.TrimPrefix(value, "env.")
			envValue := os.Getenv(envKey)
			if envValue == "" {
				log.Printf("warning: environment variable %s is not set for plugin %s", envKey, config.Name)
			}
			value = envValue
		}

		if err := os.Setenv(key, value); err != nil {
			return fmt.Errorf("failed to set environment variable %s for plugin %s: %w", key, config.Name, err)
		}
	}
	return nil
}

// getLoggerForPlugin returns a logger instance for the given plugin
// This can be customized to provide different loggers for different plugins
func getLoggerForPlugin(pluginName string) schemas.Logger {
	// For now, return nil - plugins should handle nil logger gracefully
	// In the future, this could return a custom logger per plugin
	return nil
}

// ValidatePluginConfig validates that a plugin configuration is correct
func ValidatePluginConfig(config PluginConfig) error {
	if config.Name == "" {
		return fmt.Errorf("plugin name is required")
	}

	switch config.Source {
	case PluginSourceLocal:
		if config.PluginPath == "" {
			return fmt.Errorf("plugin_path is required for local source plugins")
		}
	case PluginSourcePackage:
		if config.Package == "" {
			return fmt.Errorf("package is required for package source plugins")
		}
		// Validate package path format
		if !strings.Contains(config.Package, "/") {
			return fmt.Errorf("package path must be a valid Go module path (e.g., github.com/user/plugin)")
		}
	default:
		return fmt.Errorf("unsupported plugin source: %s. Only 'local' and 'package' sources are supported", config.Source)
	}

	return nil
}
