{
  "openapi": "3.0.3",
  "info": {
    "title": "Bifrost Gateway",
    "version": "1.3",
    "description": "The Bifrost API provides a unified interface to various AI models and services.",
    "contact": {
      "name": "Contact Us",
      "url": "https://getmaxim.ai/bifrost"
    },
    "license": {
      "name": "Apache 2.0",
      "url": "https://opensource.org/licenses/Apache-2.0"
    }
  },
  "servers": [
    {
      "url": "http://localhost:8080",
      "description": "Local development server"
    }
  ],
  "tags": [
    {
      "name": "Bifrost Core",
      "description": "Core functionalities of the Bifrost Gateway."
    },
    {
      "name": "Chat Completions",
      "description": "Endpoints for generating chat-based model responses."
    },
    {
      "name": "Text Completions",
      "description": "Endpoints for generating text-based model responses."
    },
    {
      "name": "Embeddings",
      "description": "Endpoints for creating vector embeddings from text."
    },
    {
      "name": "Audio",
      "description": "Endpoints for audio processing, including speech synthesis and transcription."
    },
    {
      "name": "Management",
      "description": "Endpoints for managing Bifrost providers and keys."
    },
    {
      "name": "Plugins",
      "description": "Endpoints for managing Bifrost plugins."
    },
    {
      "name": "MCP",
      "description": "Endpoints for Model Context Protocol (MCP) integrations."
    },
    {
      "name": "Models",
      "description": "Endpoint for listing available models."
    }
  ],
  "paths": {
    "/v1/chat/completions": {
      "post": {
        "summary": "Create Chat Completion",
        "description": "Creates a model response for the given chat conversation.",
        "operationId": "createChatCompletion",
        "tags": [
          "Bifrost Core",
          "Chat Completions"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/v1/completions": {
      "post": {
        "summary": "Create Text Completion",
        "description": "Creates a completion for the provided prompt and parameters.",
        "operationId": "createTextCompletion",
        "tags": [
          "Bifrost Core",
          "Text Completions"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TextCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/v1/embeddings": {
      "post": {
        "summary": "Create Embeddings",
        "description": "Creates an embedding vector representing the input text.",
        "operationId": "createEmbeddings",
        "tags": [
          "Bifrost Core",
          "Embeddings"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EmbeddingRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostEmbedding"
                }
              }
            }
          }
        }
      }
    },
    "/v1/responses": {
      "post": {
        "summary": "Create Response",
        "description": "Creates a response using the Responses API format.",
        "operationId": "createResponse",
        "tags": [
          "Bifrost Core",
          "Responses"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ResponsesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/v1/audio/speech": {
      "post": {
        "summary": "Create Speech",
        "description": "Generates audio from the input text.",
        "operationId": "createSpeech",
        "tags": [
          "Bifrost Core",
          "Audio"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SpeechRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Audio file",
            "content": {
              "audio/mpeg": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "audio/wav": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/v1/audio/transcriptions": {
      "post": {
        "summary": "Create Transcription",
        "description": "Transcribes audio into the input language.",
        "operationId": "createTranscription",
        "tags": [
          "Bifrost Core",
          "Audio"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "multipart/form-data": {
              "schema": {
                "$ref": "#/components/schemas/TranscriptionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostTranscribe"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/v1/models": {
      "get": {
        "summary": "List Models",
        "description": "Lists available models. If a provider is specified, returns that provider's models; otherwise, returns models from all configured providers.\n\n**Note:** Only fields returned by the provider API are included in the response. Fields not provided by the provider are omitted from the JSON response.",
        "operationId": "listModels",
        "tags": [
          "Bifrost Core",
          "Models"
        ],
        "parameters": [
          {
            "name": "provider",
            "in": "query",
            "required": false,
            "description": "The provider to list models from. If not set, returns models from all configured providers in Bifrost.",
            "schema": {
              "$ref": "#/components/schemas/ModelProvider"
            },
            "example": "openai"
          },
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "description": "Number of models to return per page. If not specified, the provider's default page size will be used.",
            "schema": {
              "type": "integer"
            },
            "example": 100
          },
          {
            "name": "page_token",
            "in": "query",
            "required": false,
            "description": "Token received from previous request to retrieve the next page of results. Omit this parameter to fetch the first page.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response with list of models",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListModelsResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequest"
          },
          "500": {
            "$ref": "#/components/responses/InternalServerError"
          }
        }
      }
    },
    "/health": {
      "get": {
        "summary": "Get Health",
        "description": "Returns the health of the server. This endpoint can be safely used as liveness probe and readiness probe for Kubernetes. It also internally validates connection to config store, log store, vector store",
        "operationId": "getHealth",
        "tags": [
          "Health"
        ],
        "responses": {
          "200": {
            "description": "Server is healthy and all stores are available",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string",
                      "example": "ok"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "Service unavailable. One or more required stores (config store, log store, or vector store) are not available."
          }
        }
      }
    },
    "/metrics": {
      "get": {
        "summary": "Get Prometheus Metrics",
        "description": "Returns Prometheus-compatible metrics for monitoring request counts, latency, token usage, and error rates.",
        "operationId": "getMetrics",
        "tags": [
          "Monitoring"
        ],
        "responses": {
          "200": {
            "description": "Prometheus metrics in text format",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                },
                "example": "# HELP http_requests_total Total number of HTTP requests\n# TYPE http_requests_total counter\nhttp_requests_total{method=\"POST\",handler=\"/v1/chat/completions\",code=\"200\"} 42\n"
              }
            }
          }
        }
      }
    },
    "/v1/mcp/tool/execute": {
      "post": {
        "tags": [
          "MCP"
        ],
        "summary": "Execute an MCP tool",
        "description": "Executes a tool call from the Model Context Protocol (MCP) and returns the result.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatAssistantMessageToolCall"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Tool execution result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatMessage"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request format"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/mcp/clients": {
      "get": {
        "tags": [
          "MCP"
        ],
        "summary": "Get all MCP clients",
        "description": "Retrieves a list of all configured MCP clients and their connection status.",
        "responses": {
          "200": {
            "description": "A list of MCP clients",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MCPClient"
                  }
                }
              }
            }
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/api/mcp/client": {
      "post": {
        "tags": [
          "MCP"
        ],
        "summary": "Add a new MCP client",
        "description": "Adds and connects a new MCP client configuration.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MCPClientConfig"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Client added successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string",
                      "example": "success"
                    },
                    "message": {
                      "type": "string",
                      "example": "MCP client added successfully"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid request format"
          },
          "500": {
            "description": "Failed to add MCP client"
          }
        }
      }
    },
    "/api/mcp/client/{name}": {
      "put": {
        "tags": [
          "MCP"
        ],
        "summary": "Edit MCP client tools",
        "description": "Edits the list of tools to be executed for a specific MCP client.",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The name of the MCP client to edit."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "tools_to_execute": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "description": "Include-only list of tools. '*' means all tools, [] means no tools."
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Client tools edited successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string",
                      "example": "success"
                    },
                    "message": {
                      "type": "string",
                      "example": "MCP client tools edited successfully"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid request format or name"
          },
          "500": {
            "description": "Failed to edit MCP client tools"
          }
        }
      },
      "delete": {
        "tags": [
          "MCP"
        ],
        "summary": "Remove an MCP client",
        "description": "Removes an MCP client configuration and disconnects it.",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The name of the MCP client to remove."
          }
        ],
        "responses": {
          "200": {
            "description": "Client removed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string",
                      "example": "success"
                    },
                    "message": {
                      "type": "string",
                      "example": "MCP client removed successfully"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid name"
          },
          "500": {
            "description": "Failed to remove MCP client"
          }
        }
      }
    },
    "/api/mcp/client/{name}/reconnect": {
      "post": {
        "tags": [
          "MCP"
        ],
        "summary": "Reconnect an MCP client",
        "description": "Attempts to reconnect a disconnected MCP client.",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The name of the MCP client to reconnect."
          }
        ],
        "responses": {
          "200": {
            "description": "Client reconnected successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string",
                      "example": "success"
                    },
                    "message": {
                      "type": "string",
                      "example": "MCP client reconnected successfully"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid name"
          },
          "500": {
            "description": "Failed to reconnect MCP client"
          }
        }
      }
    },
    "/api/version": {
      "get": {
        "summary": "Get API Version",
        "description": "Retrieves the current version of the Bifrost API.",
        "operationId": "getVersion",
        "tags": [
          "General"
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/api/keys": {
      "get": {
        "summary": "List All Keys",
        "description": "Retrieves a list of all API keys configured across all providers.",
        "operationId": "listKeys",
        "tags": [
          "Providers"
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Key"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/providers": {
      "get": {
        "summary": "List all providers",
        "operationId": "listProviders",
        "tags": [
          "Providers"
        ],
        "responses": {
          "200": {
            "description": "A list of all configured providers.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListProvidersResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Add a new provider",
        "operationId": "addProvider",
        "tags": [
          "Providers"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddProviderRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The newly added provider's configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProviderResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request body or parameters."
          },
          "409": {
            "description": "Provider already exists."
          }
        }
      }
    },
    "/api/providers/{provider}": {
      "get": {
        "summary": "Get a specific provider",
        "operationId": "getProvider",
        "tags": [
          "Providers"
        ],
        "parameters": [
          {
            "name": "provider",
            "in": "path",
            "required": true,
            "description": "The name of the provider",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The requested provider's configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProviderResponse"
                }
              }
            }
          },
          "404": {
            "description": "Provider not found."
          }
        }
      },
      "put": {
        "summary": "Update a provider's configuration",
        "description": "This endpoint upserts the provider configuration. All fields must be provided in the request body, as partial updates are not supported.",
        "operationId": "updateProvider",
        "tags": [
          "Providers"
        ],
        "parameters": [
          {
            "name": "provider",
            "in": "path",
            "required": true,
            "description": "The name of the provider to update",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateProviderRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The updated provider's configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProviderResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request body or parameters."
          },
          "404": {
            "description": "Provider not found."
          }
        }
      },
      "delete": {
        "summary": "Remove a provider",
        "operationId": "deleteProvider",
        "tags": [
          "Providers"
        ],
        "parameters": [
          {
            "name": "provider",
            "in": "path",
            "required": true,
            "description": "The name of the provider to delete",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Confirmation of provider deletion.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProviderResponse"
                }
              }
            }
          },
          "404": {
            "description": "Provider not found."
          }
        }
      }
    },
    "/api/plugins": {
      "get": {
        "summary": "Get All Plugins",
        "description": "Retrieves a list of all configured plugins.",
        "operationId": "getPlugins",
        "tags": [
          "Plugins"
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "plugins": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/Plugin"
                      }
                    },
                    "count": {
                      "type": "integer"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create Plugin",
        "description": "Creates a new plugin configuration.",
        "operationId": "createPlugin",
        "tags": [
          "Plugins"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreatePluginRequest"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Plugin created successfully"
          }
        }
      }
    },
    "/api/plugins/{name}": {
      "get": {
        "summary": "Get Plugin",
        "description": "Retrieves a specific plugin configuration by name.",
        "operationId": "getPlugin",
        "tags": [
          "Plugins"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Plugin"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update Plugin",
        "description": "Updates an existing plugin configuration.",
        "operationId": "updatePlugin",
        "tags": [
          "Plugins"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdatePluginRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Plugin updated successfully"
          }
        }
      },
      "delete": {
        "summary": "Delete Plugin",
        "description": "Deletes a plugin configuration.",
        "operationId": "deletePlugin",
        "tags": [
          "Plugins"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Plugin deleted successfully"
          }
        }
      }
    },
    "/api/governance/virtual-keys": {
      "get": {
        "summary": "Get All Virtual Keys",
        "description": "Retrieves a list of all virtual keys.",
        "operationId": "getVirtualKeys",
        "tags": [
          "Governance"
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "virtual_keys": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/VirtualKey"
                      }
                    },
                    "count": {
                      "type": "integer"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create Virtual Key",
        "description": "Creates a new virtual key.",
        "operationId": "createVirtualKey",
        "tags": [
          "Governance"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateVirtualKeyRequest"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Virtual key created successfully"
          }
        }
      }
    },
    "/api/governance/virtual-keys/{vk_id}": {
      "get": {
        "summary": "Get Virtual Key",
        "description": "Retrieves a specific virtual key by ID.",
        "operationId": "getVirtualKey",
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "name": "vk_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VirtualKey"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update Virtual Key",
        "description": "Updates an existing virtual key.",
        "operationId": "updateVirtualKey",
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "name": "vk_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateVirtualKeyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Virtual key updated successfully"
          }
        }
      },
      "delete": {
        "summary": "Delete Virtual Key",
        "description": "Deletes a virtual key.",
        "operationId": "deleteVirtualKey",
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "name": "vk_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Virtual key deleted successfully"
          }
        }
      }
    },
    "/api/governance/teams": {
      "get": {
        "summary": "Get All Teams",
        "description": "Retrieves a list of all teams.",
        "operationId": "getTeams",
        "tags": [
          "Governance"
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "teams": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/Team"
                      }
                    },
                    "count": {
                      "type": "integer"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create Team",
        "description": "Creates a new team.",
        "operationId": "createTeam",
        "tags": [
          "Governance"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateTeamRequest"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Team created successfully"
          }
        }
      }
    },
    "/api/governance/teams/{team_id}": {
      "get": {
        "summary": "Get Team",
        "description": "Retrieves a specific team by ID.",
        "operationId": "getTeam",
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Team"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update Team",
        "description": "Updates an existing team.",
        "operationId": "updateTeam",
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateTeamRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Team updated successfully"
          }
        }
      },
      "delete": {
        "summary": "Delete Team",
        "description": "Deletes a team.",
        "operationId": "deleteTeam",
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Team deleted successfully"
          }
        }
      }
    },
    "/api/governance/customers": {
      "get": {
        "summary": "Get All Customers",
        "description": "Retrieves a list of all customers.",
        "operationId": "getCustomers",
        "tags": [
          "Governance"
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "customers": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/Customer"
                      }
                    },
                    "count": {
                      "type": "integer"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create Customer",
        "description": "Creates a new customer.",
        "operationId": "createCustomer",
        "tags": [
          "Governance"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateCustomerRequest"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Customer created successfully"
          }
        }
      }
    },
    "/api/governance/customers/{customer_id}": {
      "get": {
        "summary": "Get Customer",
        "description": "Retrieves a specific customer by ID.",
        "operationId": "getCustomer",
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "name": "customer_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Customer"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update Customer",
        "description": "Updates an existing customer.",
        "operationId": "updateCustomer",
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "name": "customer_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateCustomerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Customer updated successfully"
          }
        }
      },
      "delete": {
        "summary": "Delete Customer",
        "description": "Deletes a customer.",
        "operationId": "deleteCustomer",
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "name": "customer_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Customer deleted successfully"
          }
        }
      }
    },
    "/ws": {
      "get": {
        "summary": "WebSocket for Log Streaming",
        "description": "Establishes a WebSocket connection for real-time log streaming.",
        "operationId": "webSocketLogStream",
        "tags": [
          "Logging"
        ],
        "responses": {
          "101": {
            "description": "Switching Protocols - WebSocket connection established"
          }
        }
      }
    },
    "/api/logs": {
      "get": {
        "summary": "Search and filter logs",
        "operationId": "searchLogs",
        "tags": [
          "Logging"
        ],
        "parameters": [
          {
            "name": "providers",
            "in": "query",
            "description": "Comma-separated list of providers to filter by",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "models",
            "in": "query",
            "description": "Comma-separated list of models to filter by",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "status",
            "in": "query",
            "description": "Comma-separated list of statuses to filter by",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "objects",
            "in": "query",
            "description": "Comma-separated list of objects to filter by",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "start_time",
            "in": "query",
            "description": "Start time for the time range filter (RFC3339 format)",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "end_time",
            "in": "query",
            "description": "End time for the time range filter (RFC3339 format)",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "min_latency",
            "in": "query",
            "schema": {
              "type": "number"
            }
          },
          {
            "name": "max_latency",
            "in": "query",
            "schema": {
              "type": "number"
            }
          },
          {
            "name": "min_tokens",
            "in": "query",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "max_tokens",
            "in": "query",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "min_cost",
            "in": "query",
            "schema": {
              "type": "number"
            }
          },
          {
            "name": "max_cost",
            "in": "query",
            "schema": {
              "type": "number"
            }
          },
          {
            "name": "content_search",
            "in": "query",
            "description": "Full-text search in request/response bodies",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of logs to return",
            "schema": {
              "type": "integer",
              "default": 50,
              "maximum": 1000
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of logs to skip",
            "schema": {
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "sort_by",
            "in": "query",
            "description": "Field to sort by",
            "schema": {
              "type": "string",
              "enum": [
                "timestamp",
                "latency",
                "tokens",
                "cost"
              ],
              "default": "timestamp"
            }
          },
          {
            "name": "order",
            "in": "query",
            "description": "Sort order",
            "schema": {
              "type": "string",
              "enum": [
                "asc",
                "desc"
              ],
              "default": "desc"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A paginated list of logs matching the criteria.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResult"
                }
              }
            }
          }
        }
      }
    },
    "/api/logs/dropped": {
      "get": {
        "summary": "Get the number of dropped requests",
        "operationId": "getDroppedRequests",
        "tags": [
          "Logging"
        ],
        "responses": {
          "200": {
            "description": "The total count of dropped requests.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "dropped_requests": {
                      "type": "integer",
                      "format": "int64"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/openai/v1/completions": {
      "post": {
        "summary": "OpenAI Compatible Text Completions",
        "description": "OpenAI-compatible text completions endpoint that converts requests to Bifrost format and returns OpenAI-compatible responses.",
        "operationId": "openaiTextCompletions",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TextCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI-compatible text completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/openai/completions": {
      "post": {
        "summary": "OpenAI Compatible Text Completions (alternative path)",
        "description": "OpenAI-compatible text completions endpoint that converts requests to Bifrost format and returns OpenAI-compatible responses.",
        "operationId": "openaiTextCompletionsAlt",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TextCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI-compatible text completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/openai/deployments/{deployment-id}/completions": {
      "post": {
        "summary": "Azure OpenAI Compatible Text Completions",
        "description": "Azure OpenAI-compatible text completions endpoint for specific deployments.",
        "operationId": "azureTextCompletions",
        "tags": [
          "Integration - OpenAI"
        ],
        "parameters": [
          {
            "name": "deployment-id",
            "in": "path",
            "required": true,
            "description": "Azure deployment ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TextCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Azure OpenAI-compatible text completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/openai/v1/chat/completions": {
      "post": {
        "summary": "OpenAI Compatible Chat Completions",
        "description": "OpenAI-compatible chat completions endpoint that converts requests to Bifrost format and returns OpenAI-compatible responses.",
        "operationId": "openaiChatCompletions",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI-compatible chat completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/openai/chat/completions": {
      "post": {
        "summary": "OpenAI Compatible Chat Completions (alternative path)",
        "description": "OpenAI-compatible chat completions endpoint that converts requests to Bifrost format and returns OpenAI-compatible responses.",
        "operationId": "openaiChatCompletionsAlt",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI-compatible chat completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/openai/deployments/{deployment-id}/chat/completions": {
      "post": {
        "summary": "Azure OpenAI Compatible Chat Completions",
        "description": "Azure OpenAI-compatible chat completions endpoint for specific deployments.",
        "operationId": "azureChatCompletions",
        "tags": [
          "Integration - OpenAI"
        ],
        "parameters": [
          {
            "name": "deployment-id",
            "in": "path",
            "required": true,
            "description": "Azure deployment ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Azure OpenAI-compatible chat completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/openai/v1/responses": {
      "post": {
        "summary": "OpenAI Compatible Responses",
        "description": "OpenAI-compatible responses endpoint that converts requests to Bifrost format and returns OpenAI-compatible responses.",
        "operationId": "openaiResponses",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ResponsesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI-compatible responses response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/openai/responses": {
      "post": {
        "summary": "OpenAI Compatible Responses (alternative path)",
        "description": "OpenAI-compatible responses endpoint that converts requests to Bifrost format and returns OpenAI-compatible responses.",
        "operationId": "openaiResponsesAlt",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ResponsesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI-compatible responses response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/openai/deployments/{deployment-id}/responses": {
      "post": {
        "summary": "Azure OpenAI Compatible Responses",
        "description": "Azure OpenAI-compatible responses endpoint for specific deployments.",
        "operationId": "azureResponses",
        "tags": [
          "Integration - OpenAI"
        ],
        "parameters": [
          {
            "name": "deployment-id",
            "in": "path",
            "required": true,
            "description": "Azure deployment ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ResponsesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Azure OpenAI-compatible responses response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/openai/v1/embeddings": {
      "post": {
        "summary": "OpenAI Compatible Embeddings",
        "description": "OpenAI-compatible embeddings endpoint that converts requests to Bifrost format and returns OpenAI-compatible responses.",
        "operationId": "openaiEmbeddings",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EmbeddingRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI-compatible embeddings response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostEmbedding"
                }
              }
            }
          }
        }
      }
    },
    "/openai/embeddings": {
      "post": {
        "summary": "OpenAI Compatible Embeddings (alternative path)",
        "description": "OpenAI-compatible embeddings endpoint that converts requests to Bifrost format and returns OpenAI-compatible responses.",
        "operationId": "openaiEmbeddingsAlt",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EmbeddingRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI-compatible embeddings response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostEmbedding"
                }
              }
            }
          }
        }
      }
    },
    "/openai/deployments/{deployment-id}/embeddings": {
      "post": {
        "summary": "Azure OpenAI Compatible Embeddings",
        "description": "Azure OpenAI-compatible embeddings endpoint for specific deployments.",
        "operationId": "azureEmbeddings",
        "tags": [
          "Integration - OpenAI"
        ],
        "parameters": [
          {
            "name": "deployment-id",
            "in": "path",
            "required": true,
            "description": "Azure deployment ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EmbeddingRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Azure OpenAI-compatible embeddings response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostEmbedding"
                }
              }
            }
          }
        }
      }
    },
    "/openai/v1/audio/speech": {
      "post": {
        "summary": "OpenAI Compatible Speech Synthesis",
        "description": "OpenAI-compatible speech synthesis endpoint.",
        "operationId": "openaiSpeech",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SpeechRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Audio file",
            "content": {
              "audio/mpeg": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          }
        }
      }
    },
    "/openai/audio/speech": {
      "post": {
        "summary": "OpenAI Compatible Speech Synthesis (alternative path)",
        "description": "OpenAI-compatible speech synthesis endpoint.",
        "operationId": "openaiSpeechAlt",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SpeechRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Audio file",
            "content": {
              "audio/mpeg": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          }
        }
      }
    },
    "/openai/deployments/{deployment-id}/audio/speech": {
      "post": {
        "summary": "Azure OpenAI Compatible Speech Synthesis",
        "description": "Azure OpenAI-compatible speech synthesis endpoint for specific deployments.",
        "operationId": "azureSpeech",
        "tags": [
          "Integration - OpenAI"
        ],
        "parameters": [
          {
            "name": "deployment-id",
            "in": "path",
            "required": true,
            "description": "Azure deployment ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SpeechRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Audio file",
            "content": {
              "audio/mpeg": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          }
        }
      }
    },
    "/openai/v1/audio/transcriptions": {
      "post": {
        "summary": "OpenAI Compatible Audio Transcription",
        "description": "OpenAI-compatible audio transcription endpoint.",
        "operationId": "openaiTranscription",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "multipart/form-data": {
              "schema": {
                "$ref": "#/components/schemas/TranscriptionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transcription result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostTranscribe"
                }
              }
            }
          }
        }
      }
    },
    "/openai/audio/transcriptions": {
      "post": {
        "summary": "OpenAI Compatible Audio Transcription (alternative path)",
        "description": "OpenAI-compatible audio transcription endpoint.",
        "operationId": "openaiTranscriptionAlt",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "multipart/form-data": {
              "schema": {
                "$ref": "#/components/schemas/TranscriptionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transcription result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostTranscribe"
                }
              }
            }
          }
        }
      }
    },
    "/openai/deployments/{deployment-id}/audio/transcriptions": {
      "post": {
        "summary": "Azure OpenAI Compatible Audio Transcription",
        "description": "Azure OpenAI-compatible audio transcription endpoint for specific deployments.",
        "operationId": "azureTranscription",
        "tags": [
          "Integration - OpenAI"
        ],
        "parameters": [
          {
            "name": "deployment-id",
            "in": "path",
            "required": true,
            "description": "Azure deployment ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "multipart/form-data": {
              "schema": {
                "$ref": "#/components/schemas/TranscriptionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transcription result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostTranscribe"
                }
              }
            }
          }
        }
      }
    },
    "/anthropic/v1/complete": {
      "post": {
        "summary": "Anthropic Compatible Text Completions",
        "description": "Anthropic-compatible text completions endpoint.",
        "operationId": "anthropicTextCompletions",
        "tags": [
          "Integration - Anthropic"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TextCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Anthropic-compatible text completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/anthropic/v1/messages": {
      "post": {
        "summary": "Anthropic Compatible Messages",
        "description": "Anthropic-compatible messages endpoint.",
        "operationId": "anthropicMessages",
        "tags": [
          "Integration - Anthropic"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Anthropic-compatible message response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/genai/v1beta/models/{model}:generateContent": {
      "post": {
        "summary": "Google Gemini Compatible Completions",
        "description": "Google Gemini-compatible completions endpoint.",
        "operationId": "geminiCompletions",
        "tags": [
          "Integration - Gemini"
        ],
        "parameters": [
          {
            "name": "model",
            "in": "path",
            "required": true,
            "description": "Model name",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Gemini-compatible completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/langchain/v1/chat/completions": {
      "post": {
        "summary": "LangChain/OpenAI Compatible Chat Completions",
        "description": "LangChain compatible endpoint for OpenAI-style chat completions.",
        "operationId": "langchainOpenAIChatCompletions",
        "tags": [
          "Integration - LangChain",
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI-compatible chat completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/langchain/v1/complete": {
      "post": {
        "summary": "LangChain/Anthropic Compatible Text Completions",
        "description": "LangChain compatible endpoint for Anthropic-style text completions.",
        "operationId": "langchainAnthropicTextCompletions",
        "tags": [
          "Integration - LangChain",
          "Integration - Anthropic"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TextCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Anthropic-compatible text completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/langchain/v1/messages": {
      "post": {
        "summary": "LangChain/Anthropic Compatible Messages",
        "description": "LangChain compatible endpoint for Anthropic-style messages.",
        "operationId": "langchainAnthropicMessages",
        "tags": [
          "Integration - LangChain",
          "Integration - Anthropic"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Anthropic-compatible message response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/langchain/v1beta/models/{model}:generateContent": {
      "post": {
        "summary": "LangChain/Gemini Compatible Completions",
        "description": "LangChain compatible endpoint for Google Gemini-style completions.",
        "operationId": "langchainGeminiCompletions",
        "tags": [
          "Integration - LangChain",
          "Integration - Gemini"
        ],
        "parameters": [
          {
            "name": "model",
            "in": "path",
            "required": true,
            "description": "Model name",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Gemini-compatible completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/litellm/v1/chat/completions": {
      "post": {
        "summary": "LiteLLM/OpenAI Compatible Chat Completions",
        "description": "LiteLLM compatible endpoint for OpenAI-style chat completions.",
        "operationId": "litellmOpenAIChatCompletions",
        "tags": [
          "Integration - LiteLLM",
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI-compatible chat completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/litellm/chat/completions": {
      "post": {
        "summary": "LiteLLM/OpenAI Compatible Chat Completions (alternative path)",
        "description": "LiteLLM compatible endpoint for OpenAI-style chat completions.",
        "operationId": "litellmOpenAIChatCompletionsAlt",
        "tags": [
          "Integration - LiteLLM",
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI-compatible chat completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/litellm/v1/complete": {
      "post": {
        "summary": "LiteLLM/Anthropic Compatible Text Completions",
        "description": "LiteLLM compatible endpoint for Anthropic-style text completions.",
        "operationId": "litellmAnthropicTextCompletions",
        "tags": [
          "Integration - LiteLLM",
          "Integration - Anthropic"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TextCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Anthropic-compatible text completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/litellm/v1/messages": {
      "post": {
        "summary": "LiteLLM/Anthropic Compatible Messages",
        "description": "LiteLLM compatible endpoint for Anthropic-style messages.",
        "operationId": "litellmAnthropicMessages",
        "tags": [
          "Integration - LiteLLM",
          "Integration - Anthropic"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Anthropic-compatible message response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/litellm/v1beta/models/{model}:generateContent": {
      "post": {
        "summary": "LiteLLM/Gemini Compatible Completions",
        "description": "LiteLLM compatible endpoint for Google Gemini-style completions.",
        "operationId": "litellmGeminiCompletions",
        "tags": [
          "Integration - LiteLLM",
          "Integration - Gemini"
        ],
        "parameters": [
          {
            "name": "model",
            "in": "path",
            "required": true,
            "description": "Model name",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Gemini-compatible completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "ChatCompletionRequest": {
        "type": "object",
        "required": [
          "model",
          "messages"
        ],
        "properties": {
          "model": {
            "type": "string",
            "description": "Model identifier in 'provider/model' format (e.g., 'openai/gpt-4o-mini', 'anthropic/claude-3-sonnet-20240229')",
            "example": "openai/gpt-4o-mini"
          },
          "messages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChatMessage"
            },
            "description": "Array of chat messages",
            "minItems": 1
          },
          "max_tokens": {
            "type": "integer",
            "minimum": 1,
            "description": "Maximum number of tokens to generate. Note: this is an alias for `max_completion_tokens` and will be overridden by it if both are present.",
            "example": 1000
          },
          "temperature": {
            "type": "number",
            "minimum": 0,
            "maximum": 2,
            "description": "Controls randomness in the output. Higher values make the output more random, while lower values make it more deterministic."
          },
          "top_p": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "description": "Controls diversity via nucleus sampling. 0.5 means half of all likelihood-weighted options are considered."
          },
          "n": {
            "type": "integer",
            "description": "Number of chat completion choices to generate for each input message.",
            "default": 1
          },
          "stream": {
            "type": "boolean",
            "description": "If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only server-sent events as they become available.",
            "default": false
          },
          "stream_options": {
            "$ref": "#/components/schemas/ChatStreamOptions"
          },
          "stop": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ],
            "description": "Up to 4 sequences where the API will stop generating further tokens."
          },
          "presence_penalty": {
            "type": "number",
            "minimum": -2,
            "maximum": 2,
            "description": "Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics."
          },
          "frequency_penalty": {
            "type": "number",
            "minimum": -2,
            "maximum": 2,
            "description": "Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim."
          },
          "logit_bias": {
            "type": "object",
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Modify the likelihood of specified tokens appearing in the completion. Accepts a JSON object that maps tokens to an associated bias value from -100 to 100."
          },
          "logprobs": {
            "type": "boolean",
            "description": "Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the `content` of `message`.",
            "default": false
          },
          "top_logprobs": {
            "type": "integer",
            "minimum": 0,
            "maximum": 20,
            "description": "An integer between 0 and 20. The number of most likely tokens to return at each token position, each with an associated log probability. `logprobs` must be set to `true` if this parameter is used."
          },
          "max_completion_tokens": {
            "type": "integer",
            "description": "The maximum number of tokens that can be generated in the chat completion."
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "description": "A set of key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format."
          },
          "modalities": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of modalities to use for the response."
          },
          "parallel_tool_calls": {
            "type": "boolean",
            "description": "Whether to enable parallel tool calls. If set to `true`, the model will be able to call multiple tools in a single response."
          },
          "prompt_cache_key": {
            "type": "string",
            "description": "A key to use for caching the prompt."
          },
          "reasoning_effort": {
            "type": "string",
            "description": "The reasoning effort to use for the response."
          },
          "response_format": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "text",
                  "json_object"
                ],
                "description": "The format of the response. Can be `text` or `json_object`."
              }
            }
          },
          "safety_identifier": {
            "type": "string",
            "description": "A unique identifier for the safety settings to use for the response."
          },
          "seed": {
            "type": "integer",
            "description": "This feature is in Beta. If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result. Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend."
          },
          "service_tier": {
            "type": "string",
            "enum": [
              "auto",
              "default"
            ],
            "description": "The service tier to use for the response. Can be `auto` or `default`."
          },
          "store": {
            "type": "boolean",
            "description": "Whether to store the request and response in the log store."
          },
          "tool_choice": {
            "$ref": "#/components/schemas/ChatToolChoice"
          },
          "tools": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChatTool"
            }
          },
          "user": {
            "type": "string",
            "description": "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse."
          },
          "verbosity": {
            "type": "string",
            "description": "The verbosity level of the response."
          },
          "fallbacks": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Fallback model names in 'provider/model' format",
            "example": [
              "anthropic/claude-3-sonnet-20240229",
              "openai/gpt-4o"
            ]
          }
        }
      },
      "ChatStreamOptions": {
        "type": "object",
        "properties": {
          "include_usage": {
            "type": "boolean",
            "description": "If set, an additional chunk will be streamed before the `data: [DONE]` message. The `usage` field on this chunk shows the token usage stats for the completion, and the `model` field identify the model used."
          }
        }
      },
      "ChatTool": {
        "type": "object",
        "required": [
          "type",
          "function"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "function"
            ],
            "description": "The type of the tool. Currently, only `function` is supported."
          },
          "function": {
            "type": "object",
            "required": [
              "name"
            ],
            "properties": {
              "description": {
                "type": "string",
                "description": "A description of what the function does."
              },
              "name": {
                "type": "string",
                "description": "The name of the function to be called."
              },
              "parameters": {
                "type": "object",
                "description": "The parameters the functions accepts, described as a JSON Schema object."
              }
            }
          }
        }
      },
      "ChatToolChoice": {
        "oneOf": [
          {
            "type": "string",
            "enum": [
              "none",
              "auto",
              "required"
            ]
          },
          {
            "$ref": "#/components/schemas/ChatTool"
          }
        ],
        "description": "Controls which (if any) function is called by the model. `none` means the model will not call a function and instead generates a message. `auto` means the model can pick between generating a message or calling a function. `required` means the model must call a function. Specifying a particular function via `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that function."
      },
      "TextCompletionRequest": {
        "type": "object",
        "required": [
          "model",
          "text"
        ],
        "properties": {
          "model": {
            "type": "string",
            "description": "Model identifier in 'provider/model' format (e.g., 'anthropic/claude-2.1')",
            "example": "anthropic/claude-2.1"
          },
          "prompt": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ],
            "description": "Text prompt for completion",
            "example": "The benefits of artificial intelligence include"
          },
          "stream": {
            "type": "boolean",
            "description": "If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only server-sent events as they become available.",
            "default": false
          },
          "best_of": {
            "type": "integer",
            "description": "Generates `best_of` completions server-side and returns the 'best' one. See `n` for comparison."
          },
          "echo": {
            "type": "boolean",
            "description": "Echo back the prompt in addition to the completion.",
            "default": false
          },
          "frequency_penalty": {
            "type": "number",
            "minimum": -2,
            "maximum": 2,
            "description": "Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim."
          },
          "logit_bias": {
            "type": "object",
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Modify the likelihood of specified tokens appearing in the completion. Accepts a JSON object that maps tokens to an associated bias value from -100 to 100."
          },
          "logprobs": {
            "type": "integer",
            "description": "Include the log probabilities on the `logprobs` most likely tokens, as well the chosen tokens."
          },
          "max_tokens": {
            "type": "integer",
            "minimum": 1,
            "description": "Maximum number of tokens to generate",
            "example": 1000
          },
          "n": {
            "type": "integer",
            "description": "How many completions to generate for each prompt.",
            "default": 1
          },
          "presence_penalty": {
            "type": "number",
            "minimum": -2,
            "maximum": 2,
            "description": "Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics."
          },
          "seed": {
            "type": "integer",
            "description": "This feature is in Beta. If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result. Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend."
          },
          "stop": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ],
            "description": "Up to 4 sequences where the API will stop generating further tokens."
          },
          "stream_options": {
            "$ref": "#/components/schemas/ChatStreamOptions"
          },
          "suffix": {
            "type": "string",
            "description": "The suffix that comes after a completion of inserted text."
          },
          "temperature": {
            "type": "number",
            "minimum": 0,
            "maximum": 2,
            "description": "Controls randomness in the output. Higher values make the output more random, while lower values make it more deterministic."
          },
          "top_p": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "description": "Controls diversity via nucleus sampling. 0.5 means half of all likelihood-weighted options are considered."
          },
          "user": {
            "type": "string",
            "description": "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse."
          },
          "fallbacks": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Fallback model names in 'provider/model' format",
            "example": [
              "anthropic/claude-3-sonnet-20240229",
              "openai/gpt-4o"
            ]
          }
        }
      },
      "ModelProvider": {
        "type": "string",
        "enum": [
          "openai",
          "anthropic",
          "azure",
          "bedrock",
          "cohere",
          "vertex",
          "mistral",
          "ollama",
          "gemini",
          "groq",
          "openrouter",
          "sgl",
          "parasail",
          "cerebras"
        ],
        "description": "AI model provider",
        "example": "openai"
      },
      "RequestType": {
        "type": "string",
        "enum": [
          "list_models",
          "text_completion",
          "chat_completion",
          "chat_completion_stream",
          "responses",
          "responses_stream",
          "embedding",
          "speech",
          "speech_stream",
          "transcription",
          "transcription_stream"
        ],
        "description": "Request type"
      },
      "ChatMessage": {
        "type": "object",
        "required": [
          "role"
        ],
        "properties": {
          "role": {
            "$ref": "#/components/schemas/MessageRole"
          },
          "content": {
            "oneOf": [
              {
                "type": "string",
                "description": "Simple text content",
                "example": "Hello, how are you?"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ContentBlock"
                },
                "description": "Structured content with text and images"
              }
            ],
            "description": "Message content - can be simple text or structured content with text and images"
          },
          "tool_call_id": {
            "type": "string",
            "description": "ID of the tool call (for tool messages)"
          },
          "tool_calls": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ToolCall"
            },
            "description": "Tool calls made by assistant"
          },
          "refusal": {
            "type": "string",
            "description": "Refusal message from assistant"
          },
          "annotations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Annotation"
            },
            "description": "Message annotations"
          },
          "thought": {
            "type": "string",
            "description": "Assistant's internal thought process"
          }
        }
      },
      "MessageRole": {
        "type": "string",
        "enum": [
          "user",
          "assistant",
          "system",
          "tool"
        ],
        "description": "Role of the message sender",
        "example": "user"
      },
      "ContentBlock": {
        "type": "object",
        "required": [
          "type"
        ],
        "discriminator": {
          "propertyName": "type"
        },
        "oneOf": [
          {
            "type": "object",
            "required": [
              "type",
              "text"
            ],
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "text"
                ],
                "description": "Content type for text blocks",
                "example": "text"
              },
              "text": {
                "type": "string",
                "description": "Text content",
                "example": "What do you see in this image?"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "type",
              "image_url"
            ],
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "image_url"
                ],
                "description": "Content type for image blocks",
                "example": "image_url"
              },
              "image_url": {
                "$ref": "#/components/schemas/ImageURLStruct",
                "description": "Image data"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "type",
              "input_audio"
            ],
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "input_audio"
                ],
                "description": "Content type for audio blocks",
                "example": "input_audio"
              },
              "input_audio": {
                "$ref": "#/components/schemas/InputAudioStruct",
                "description": "Audio data"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "ImageURLStruct": {
        "type": "object",
        "required": [
          "url"
        ],
        "properties": {
          "url": {
            "type": "string",
            "description": "Image URL or data URI",
            "example": "https://example.com/image.jpg"
          },
          "detail": {
            "type": "string",
            "enum": [
              "low",
              "high",
              "auto"
            ],
            "description": "Image detail level",
            "example": "auto"
          }
        }
      },
      "InputAudioStruct": {
        "type": "object",
        "required": [
          "data"
        ],
        "properties": {
          "data": {
            "type": "string",
            "description": "Audio payload (opaque string such as a data URL or provider-accepted encoded content)"
          },
          "format": {
            "type": "string",
            "description": "Optional audio format (e.g., \"mp3\", \"wav\") or MIME type (e.g., \"audio/mp3\"); providers may auto-detect when omitted"
          }
        }
      },
      "ModelParameters": {
        "type": "object",
        "properties": {
          "temperature": {
            "type": "number",
            "minimum": 0.0,
            "maximum": 2.0,
            "description": "Controls randomness in the output",
            "example": 0.7
          },
          "top_p": {
            "type": "number",
            "minimum": 0.0,
            "maximum": 1.0,
            "description": "Nucleus sampling parameter",
            "example": 0.9
          },
          "top_k": {
            "type": "integer",
            "minimum": 1,
            "description": "Top-k sampling parameter",
            "example": 40
          },
          "max_tokens": {
            "type": "integer",
            "minimum": 1,
            "description": "Maximum number of tokens to generate",
            "example": 1000
          },
          "stop_sequences": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Sequences that stop generation",
            "example": [
              "\n\n",
              "END"
            ]
          },
          "presence_penalty": {
            "type": "number",
            "minimum": -2.0,
            "maximum": 2.0,
            "description": "Penalizes repeated tokens",
            "example": 0.0
          },
          "frequency_penalty": {
            "type": "number",
            "minimum": -2.0,
            "maximum": 2.0,
            "description": "Penalizes frequent tokens",
            "example": 0.0
          },
          "tools": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Tool"
            },
            "description": "Available tools for the model"
          },
          "tool_choice": {
            "$ref": "#/components/schemas/ToolChoice"
          },
          "parallel_tool_calls": {
            "type": "boolean",
            "description": "Enable parallel tool execution",
            "example": true
          }
        }
      },
      "Tool": {
        "type": "object",
        "required": [
          "type",
          "function"
        ],
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique tool identifier"
          },
          "type": {
            "type": "string",
            "enum": [
              "function"
            ],
            "description": "Tool type",
            "example": "function"
          },
          "function": {
            "$ref": "#/components/schemas/Function"
          }
        }
      },
      "Function": {
        "type": "object",
        "required": [
          "name",
          "description",
          "parameters"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Function name",
            "example": "get_weather"
          },
          "description": {
            "type": "string",
            "description": "Function description",
            "example": "Get current weather for a location"
          },
          "parameters": {
            "$ref": "#/components/schemas/FunctionParameters"
          }
        }
      },
      "FunctionParameters": {
        "type": "object",
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "description": "Parameter type",
            "example": "object"
          },
          "description": {
            "type": "string",
            "description": "Parameter description"
          },
          "properties": {
            "type": "object",
            "additionalProperties": true,
            "description": "Parameter properties (JSON Schema)"
          },
          "required": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Required parameter names"
          },
          "enum": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Enum values for parameters"
          }
        }
      },
      "ToolChoice": {
        "type": "object",
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "none",
              "auto",
              "any",
              "function",
              "required"
            ],
            "description": "How tools should be chosen",
            "example": "auto"
          },
          "function": {
            "$ref": "#/components/schemas/ToolChoiceFunction"
          }
        }
      },
      "ToolChoiceFunction": {
        "type": "object",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the function to call",
            "example": "get_weather"
          }
        }
      },
      "ToolCall": {
        "type": "object",
        "required": [
          "function"
        ],
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique tool call identifier",
            "example": "tool_123"
          },
          "type": {
            "type": "string",
            "enum": [
              "function"
            ],
            "description": "Tool call type",
            "example": "function"
          },
          "function": {
            "$ref": "#/components/schemas/FunctionCall"
          }
        }
      },
      "FunctionCall": {
        "type": "object",
        "required": [
          "name",
          "arguments"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Function name",
            "example": "get_weather"
          },
          "arguments": {
            "type": "string",
            "description": "JSON string of function arguments",
            "example": "{\"location\": \"San Francisco, CA\"}"
          }
        }
      },
      "Annotation": {
        "type": "object",
        "required": [
          "type",
          "url_citation"
        ],
        "properties": {
          "type": {
            "type": "string",
            "description": "Annotation type"
          },
          "url_citation": {
            "$ref": "#/components/schemas/Citation"
          }
        }
      },
      "Citation": {
        "type": "object",
        "required": [
          "start_index",
          "end_index",
          "title"
        ],
        "properties": {
          "start_index": {
            "type": "integer",
            "description": "Start index in the text"
          },
          "end_index": {
            "type": "integer",
            "description": "End index in the text"
          },
          "title": {
            "type": "string",
            "description": "Citation title"
          },
          "url": {
            "type": "string",
            "description": "Citation URL"
          },
          "sources": {
            "description": "Citation sources"
          },
          "type": {
            "type": "string",
            "description": "Citation type"
          }
        }
      },
      "BifrostResponse": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique response identifier",
            "example": "chatcmpl-123"
          },
          "object": {
            "type": "string",
            "enum": [
              "text.completion",
              "chat.completion",
              "embedding",
              "speech",
              "transcribe",
              "responses.completion"
            ],
            "description": "Response type",
            "example": "chat.completion"
          },
          "choices": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BifrostChatResponseChoice"
            },
            "description": "Array of completion choices for chat and text completions. Not present for `responses` type."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BifrostEmbedding"
            },
            "description": "Array of embedding objects"
          },
          "speech": {
            "$ref": "#/components/schemas/BifrostSpeech"
          },
          "transcribe": {
            "$ref": "#/components/schemas/BifrostTranscribe"
          },
          "messages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResponsesMessage"
            },
            "description": "Array of messages for `responses` type."
          },
          "conversation_id": {
            "type": "string",
            "description": "The conversation ID."
          },
          "finish_reason": {
            "type": "string",
            "description": "The reason the model stopped generating tokens."
          },
          "stop_reason": {
            "type": "string",
            "description": "The reason the model stopped generating tokens."
          },
          "stop_sequence": {
            "type": "string",
            "description": "The stop sequence that was generated."
          },
          "prompt_cache": {
            "$ref": "#/components/schemas/ResponsesPromptCache"
          },
          "model": {
            "type": "string",
            "description": "Model used for generation",
            "example": "gpt-4o"
          },
          "created": {
            "type": "integer",
            "description": "Unix timestamp of creation",
            "example": 1677652288
          },
          "service_tier": {
            "type": "string",
            "description": "Service tier used"
          },
          "system_fingerprint": {
            "type": "string",
            "description": "System fingerprint"
          },
          "usage": {
            "$ref": "#/components/schemas/LLMUsage"
          },
          "extra_fields": {
            "$ref": "#/components/schemas/BifrostResponseExtraFields"
          }
        }
      },
      "BifrostChatResponseChoice": {
        "type": "object",
        "required": [
          "index",
          "message"
        ],
        "properties": {
          "index": {
            "type": "integer",
            "description": "Choice index",
            "example": 0
          },
          "message": {
            "$ref": "#/components/schemas/ChatMessage"
          },
          "finish_reason": {
            "type": "string",
            "enum": [
              "stop",
              "length",
              "tool_calls",
              "content_filter",
              "function_call"
            ],
            "description": "Reason completion stopped",
            "example": "stop"
          },
          "stop": {
            "type": "string",
            "description": "Stop sequence that ended generation"
          },
          "log_probs": {
            "$ref": "#/components/schemas/LogProbs"
          }
        }
      },
      "BifrostEmbeddingResponse": {
        "oneOf": [
          {
            "type": "array",
            "items": {
              "type": "number",
              "format": "float"
            }
          },
          {
            "type": "array",
            "items": {
              "type": "integer"
            }
          },
          {
            "type": "string"
          }
        ]
      },
      "BifrostEmbedding": {
        "type": "object",
        "properties": {
          "index": {
            "type": "integer"
          },
          "object": {
            "type": "string"
          },
          "embedding": {
            "$ref": "#/components/schemas/BifrostEmbeddingResponse"
          }
        }
      },
      "AudioLLMUsage": {
        "type": "object",
        "properties": {
          "characters": {
            "type": "integer"
          }
        }
      },
      "BifrostSpeech": {
        "type": "object",
        "properties": {
          "usage": {
            "$ref": "#/components/schemas/AudioLLMUsage"
          },
          "audio": {
            "type": "string",
            "format": "byte",
            "description": "The audio data as a base64-encoded string."
          }
        }
      },
      "TranscriptionLogProb": {
        "type": "object",
        "properties": {
          "token": {
            "type": "string"
          },
          "log_prob": {
            "type": "number"
          }
        }
      },
      "TranscriptionUsage": {
        "type": "object",
        "properties": {
          "prompt_tokens": {
            "type": "integer"
          },
          "completion_tokens": {
            "type": "integer"
          },
          "total_tokens": {
            "type": "integer"
          }
        }
      },
      "BifrostTranscribe": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string"
          },
          "logprobs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TranscriptionLogProb"
            }
          },
          "usage": {
            "$ref": "#/components/schemas/TranscriptionUsage"
          }
        }
      },
      "BifrostResponseExtraFields": {
        "type": "object",
        "properties": {
          "provider": {
            "$ref": "#/components/schemas/ModelProvider"
          },
          "request_type": {
            "$ref": "#/components/schemas/RequestType"
          },
          "model_requested": {
            "type": "string",
            "description": "Model requested"
          },
          "model_params": {
            "$ref": "#/components/schemas/ModelParameters"
          },
          "latency": {
            "type": "number",
            "description": "Request latency in milliseconds",
            "example": 1234
          },
          "billed_usage": {
            "$ref": "#/components/schemas/BilledLLMUsage"
          },
          "raw_response": {
            "type": "object",
            "description": "Raw provider response"
          }
        }
      },
      "BilledLLMUsage": {
        "type": "object",
        "properties": {
          "prompt_tokens": {
            "type": "number",
            "description": "Billed prompt tokens"
          },
          "completion_tokens": {
            "type": "number",
            "description": "Billed completion tokens"
          },
          "search_units": {
            "type": "number",
            "description": "Billed search units"
          },
          "classifications": {
            "type": "number",
            "description": "Billed classifications"
          }
        }
      },
      "LogProbs": {
        "type": "object",
        "properties": {
          "content": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContentLogProb"
            },
            "description": "Log probabilities for content"
          },
          "refusal": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LogProb"
            },
            "description": "Log probabilities for refusal"
          }
        }
      },
      "ContentLogProb": {
        "type": "object",
        "required": [
          "logprob",
          "token"
        ],
        "properties": {
          "bytes": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "description": "Byte representation"
          },
          "logprob": {
            "type": "number",
            "description": "Log probability",
            "example": -0.123
          },
          "token": {
            "type": "string",
            "description": "Token",
            "example": "hello"
          },
          "top_logprobs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LogProb"
            },
            "description": "Top log probabilities"
          }
        }
      },
      "LogProb": {
        "type": "object",
        "required": [
          "logprob",
          "token"
        ],
        "properties": {
          "bytes": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "description": "Byte representation"
          },
          "logprob": {
            "type": "number",
            "description": "Log probability",
            "example": -0.456
          },
          "token": {
            "type": "string",
            "description": "Token",
            "example": "world"
          }
        }
      },
      "BifrostError": {
        "type": "object",
        "required": [
          "is_bifrost_error",
          "error"
        ],
        "properties": {
          "event_id": {
            "type": "string",
            "description": "Unique error event ID",
            "example": "evt_123"
          },
          "type": {
            "type": "string",
            "description": "Error type",
            "example": "invalid_request_error"
          },
          "is_bifrost_error": {
            "type": "boolean",
            "description": "Whether error originated from Bifrost",
            "example": true
          },
          "status_code": {
            "type": "integer",
            "description": "HTTP status code",
            "example": 400
          },
          "error": {
            "$ref": "#/components/schemas/ErrorField"
          }
        }
      },
      "ErrorField": {
        "type": "object",
        "required": [
          "message"
        ],
        "properties": {
          "type": {
            "type": "string",
            "description": "Error type",
            "example": "invalid_request_error"
          },
          "code": {
            "type": "string",
            "description": "Error code",
            "example": "missing_required_parameter"
          },
          "message": {
            "type": "string",
            "description": "Human-readable error message",
            "example": "Provider is required"
          },
          "param": {
            "description": "Parameter that caused the error",
            "example": "provider"
          },
          "event_id": {
            "type": "string",
            "description": "Error event ID",
            "example": "evt_123"
          }
        }
      },
      "MCPClient": {
        "type": "object",
        "required": [
          "name",
          "config",
          "tools",
          "state"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Unique name for this MCP client",
            "example": "filesystem"
          },
          "config": {
            "$ref": "#/components/schemas/MCPClientConfig"
          },
          "tools": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Available tools from this client",
            "example": [
              "read_file",
              "list_directory",
              "write_file"
            ]
          },
          "state": {
            "$ref": "#/components/schemas/MCPConnectionState"
          }
        }
      },
      "MCPClientConfig": {
        "type": "object",
        "required": [
          "name",
          "connection_type"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Client name",
            "example": "filesystem"
          },
          "connection_type": {
            "$ref": "#/components/schemas/MCPConnectionType"
          },
          "connection_string": {
            "type": "string",
            "description": "HTTP or SSE URL (required for HTTP or SSE connections)",
            "example": "https://api.example.com/mcp"
          },
          "stdio_config": {
            "$ref": "#/components/schemas/MCPStdioConfig"
          },
          "tools_to_execute": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tools to include from this client (if specified, only these are used)",
            "example": [
              "read_file",
              "list_directory"
            ]
          }
        }
      },
      "MCPConnectionType": {
        "type": "string",
        "enum": [
          "http",
          "stdio",
          "sse",
          "inprocess"
        ],
        "description": "Communication protocol for MCP connections",
        "example": "stdio"
      },
      "MCPStdioConfig": {
        "type": "object",
        "required": [
          "command",
          "args"
        ],
        "properties": {
          "command": {
            "type": "string",
            "description": "Executable command to run",
            "example": "npx"
          },
          "args": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Command line arguments",
            "example": [
              "-y",
              "@modelcontextprotocol/server-filesystem"
            ]
          },
          "envs": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Environment variables required",
            "example": [
              "HOME",
              "USER"
            ]
          }
        }
      },
      "MCPConnectionState": {
        "type": "string",
        "enum": [
          "connected",
          "disconnected",
          "error"
        ],
        "description": "Connection state of MCP client",
        "example": "connected"
      },
      "MCPClientToolsEdit": {
        "type": "object",
        "properties": {
          "tools_to_execute": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tools to allow from this client (whitelist)",
            "example": [
              "read_file",
              "list_directory"
            ]
          }
        }
      },
      "SuccessResponse": {
        "type": "object",
        "required": [
          "status",
          "message"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "success"
            ],
            "description": "Operation status",
            "example": "success"
          },
          "message": {
            "type": "string",
            "description": "Success message",
            "example": "Operation completed successfully"
          }
        }
      },
      "Key": {
        "type": "object",
        "required": [
          "value"
        ],
        "properties": {
          "value": {
            "type": "string",
            "description": "API key value or environment variable reference",
            "example": "env.OPENAI_API_KEY"
          },
          "weight": {
            "type": "number",
            "description": "Weight for load balancing",
            "example": 1.0
          },
          "models": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Models this key can access",
            "example": [
              "gpt-4o",
              "gpt-4o-mini"
            ]
          },
          "azure_key_config": {
            "type": "object",
            "properties": {
              "endpoint": {
                "type": "string",
                "description": "Azure endpoint",
                "example": "https://your-resource.openai.azure.com"
              },
              "deployments": {
                "type": "object",
                "description": "Azure deployments",
                "example": {
                  "gpt-4o": "gpt-4o-deployment"
                }
              },
              "api_version": {
                "type": "string",
                "description": "Azure API version",
                "example": "2024-02-15-preview"
              }
            },
            "description": "Azure key configuration"
          },
          "vertex_key_config": {
            "type": "object",
            "properties": {
              "project_id": {
                "type": "string",
                "description": "Vertex project ID",
                "example": "your-project-id"
              },
              "region": {
                "type": "string",
                "description": "Vertex region",
                "example": "us-central1"
              },
              "auth_credentials": {
                "type": "string",
                "description": "Vertex auth credentials",
                "example": "env.VERTEX_AUTH_CREDENTIALS"
              }
            },
            "description": "Vertex key configuration"
          },
          "bedrock_key_config": {
            "type": "object",
            "properties": {
              "access_key": {
                "type": "string",
                "description": "Bedrock access key",
                "example": "env.AWS_ACCESS_KEY_ID"
              },
              "secret_key": {
                "type": "string",
                "description": "Bedrock secret key",
                "example": "env.AWS_SECRET_ACCESS_KEY"
              },
              "session_token": {
                "type": "string",
                "description": "Bedrock session token",
                "example": "env.AWS_SESSION_TOKEN"
              },
              "region": {
                "type": "string",
                "description": "Bedrock region",
                "example": "us-east-1"
              },
              "arn": {
                "type": "string",
                "description": "Bedrock ARN",
                "example": "arn:aws:iam::123456789012:role/BedrockRole"
              },
              "deployments": {
                "type": "object",
                "description": "Bedrock deployments",
                "example": {
                  "gpt-4o": "gpt-4o-deployment"
                }
              }
            }
          }
        }
      },
      "NetworkConfig": {
        "type": "object",
        "properties": {
          "timeout": {
            "type": "integer",
            "description": "Request timeout in seconds",
            "example": 30
          },
          "max_retries": {
            "type": "integer",
            "description": "Maximum number of retries",
            "example": 3
          }
        }
      },
      "ConcurrencyAndBufferSize": {
        "type": "object",
        "properties": {
          "concurrency": {
            "type": "integer",
            "description": "Maximum concurrent requests",
            "example": 10
          },
          "buffer_size": {
            "type": "integer",
            "description": "Request buffer size",
            "example": 100
          }
        }
      },
      "ProxyConfig": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "Proxy URL",
            "example": "http://proxy.example.com:8080"
          },
          "username": {
            "type": "string",
            "description": "Proxy username"
          },
          "password": {
            "type": "string",
            "description": "Proxy password"
          }
        }
      },
      "CustomProviderConfig": {
        "type": "object",
        "properties": {
          "base_url": {
            "type": "string",
            "description": "Custom base URL for the provider"
          },
          "headers": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional headers to send with requests"
          },
          "query_params": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional query parameters to send with requests"
          }
        }
      },
      "ClientConfig": {
        "type": "object",
        "properties": {
          "initial_pool_size": {
            "type": "integer",
            "description": "Initial pool size for sync pools",
            "example": 100
          },
          "drop_excess_requests": {
            "type": "boolean",
            "description": "Whether to drop requests when queue is full",
            "example": false
          },
          "enable_logging": {
            "type": "boolean",
            "description": "Whether logging is enabled",
            "example": true
          },
          "prometheus_labels": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Prometheus metric labels",
            "example": [
              "environment",
              "service"
            ]
          }
        }
      },
      "LogSearchResponse": {
        "type": "object",
        "required": [
          "logs",
          "total",
          "limit",
          "offset"
        ],
        "properties": {
          "logs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LogEntry"
            },
            "description": "An array of log entries that match the search criteria."
          },
          "total": {
            "type": "integer",
            "description": "Total number of matching logs",
            "example": 156
          },
          "limit": {
            "type": "integer",
            "description": "Number of logs per page",
            "example": 50
          },
          "offset": {
            "type": "integer",
            "description": "Number of logs skipped",
            "example": 0
          },
          "stats": {
            "$ref": "#/components/schemas/SearchStats"
          }
        }
      },
      "LogEntry": {
        "type": "object",
        "required": [
          "id",
          "timestamp",
          "level",
          "message"
        ],
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique log entry ID",
            "example": "log_123"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "Log entry timestamp",
            "example": "2023-12-01T10:30:00Z"
          },
          "level": {
            "type": "string",
            "enum": [
              "debug",
              "info",
              "warn",
              "error"
            ],
            "description": "Log level",
            "example": "info"
          },
          "message": {
            "type": "string",
            "description": "Log message",
            "example": "Request completed successfully"
          },
          "provider": {
            "$ref": "#/components/schemas/ModelProvider"
          },
          "model": {
            "type": "string",
            "description": "Model name used",
            "example": "gpt-4o"
          },
          "status": {
            "type": "string",
            "enum": [
              "success",
              "error"
            ],
            "description": "Request status",
            "example": "success"
          },
          "latency": {
            "type": "number",
            "description": "Request latency in milliseconds",
            "example": 1234
          },
          "tokens": {
            "type": "integer",
            "description": "Total tokens used",
            "example": 87
          },
          "cost": {
            "type": "number",
            "description": "Request cost in dollars",
            "example": 0.002
          },
          "object": {
            "type": "string",
            "enum": [
              "chat.completion",
              "text.completion"
            ],
            "description": "Request object type",
            "example": "chat.completion"
          }
        }
      },
      "DroppedRequestsResponse": {
        "type": "object",
        "required": [
          "total_dropped",
          "recent_drops"
        ],
        "properties": {
          "total_dropped": {
            "type": "integer",
            "description": "Total number of dropped requests",
            "example": 5
          },
          "recent_drops": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DroppedRequest"
            },
            "description": "Recent dropped requests"
          }
        }
      },
      "DroppedRequest": {
        "type": "object",
        "required": [
          "timestamp",
          "reason"
        ],
        "properties": {
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "When the request was dropped",
            "example": "2023-12-01T10:30:00Z"
          },
          "reason": {
            "type": "string",
            "description": "Reason for dropping the request",
            "example": "Queue overflow"
          },
          "provider": {
            "$ref": "#/components/schemas/ModelProvider"
          },
          "model": {
            "type": "string",
            "description": "Model name requested",
            "example": "gpt-4o"
          }
        }
      },
      "OpenAISpeechRequest": {
        "type": "object",
        "required": [
          "model",
          "input",
          "voice"
        ],
        "properties": {
          "model": {
            "type": "string",
            "description": "TTS model to use",
            "enum": [
              "tts-1",
              "tts-1-hd"
            ],
            "example": "tts-1"
          },
          "input": {
            "type": "string",
            "description": "Text to generate audio for (max 4096 characters)",
            "example": "The quick brown fox jumped over the lazy dog.",
            "maxLength": 4096
          },
          "voice": {
            "type": "string",
            "description": "Voice to use when generating the audio",
            "enum": [
              "alloy",
              "echo",
              "fable",
              "onyx",
              "nova",
              "shimmer"
            ],
            "example": "alloy"
          },
          "response_format": {
            "type": "string",
            "description": "Format to audio in",
            "enum": [
              "mp3",
              "opus",
              "aac",
              "flac",
              "wav",
              "pcm"
            ],
            "default": "mp3",
            "example": "mp3"
          },
          "speed": {
            "type": "number",
            "description": "Speed of the generated audio (0.25 to 4.0)",
            "minimum": 0.25,
            "maximum": 4.0,
            "default": 1.0,
            "example": 1.0
          },
          "instructions": {
            "type": "string",
            "description": "Additional instructions for voice synthesis",
            "example": "Speak slowly and clearly"
          },
          "stream_format": {
            "type": "string",
            "description": "Enable streaming with Server-Sent Events",
            "enum": [
              "sse"
            ],
            "example": "sse"
          }
        }
      },
      "OpenAITranscriptionRequest": {
        "type": "object",
        "required": [
          "model",
          "file"
        ],
        "properties": {
          "model": {
            "type": "string",
            "description": "ID of the model to use",
            "enum": [
              "whisper-1"
            ],
            "example": "whisper-1"
          },
          "file": {
            "type": "string",
            "format": "binary",
            "description": "Audio file object to transcribe (mp3, mp4, mpeg, mpga, m4a, wav, webm, max 25MB)"
          },
          "language": {
            "type": "string",
            "description": "Language of the input audio (ISO-639-1 format)",
            "example": "en"
          },
          "prompt": {
            "type": "string",
            "description": "Optional text to guide the model's style or continue a previous audio segment",
            "example": "ZyntriQix, Digique Plus, CynapseFive, VortiQore V8, EchoNix Pro, CyberLeap"
          },
          "response_format": {
            "type": "string",
            "description": "Format of the transcript output",
            "enum": [
              "json",
              "text",
              "srt",
              "verbose_json",
              "vtt"
            ],
            "default": "json",
            "example": "json"
          },
          "temperature": {
            "type": "number",
            "description": "Sampling temperature (0 to 1)",
            "minimum": 0,
            "maximum": 1,
            "default": 0,
            "example": 0
          },
          "include": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "segments"
              ]
            },
            "description": "Additional data to include in the response"
          },
          "timestamp_granularities": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "word",
                "segment"
              ]
            },
            "description": "Timestamp granularities to populate for this transcription",
            "default": [
              "segment"
            ]
          },
          "stream": {
            "type": "boolean",
            "description": "Enable streaming transcription",
            "default": false,
            "example": false
          }
        }
      },
      "OpenAITranscriptionResponse": {
        "type": "object",
        "required": [
          "text"
        ],
        "properties": {
          "text": {
            "type": "string",
            "description": "The transcribed text",
            "example": "Imagine the wildest idea that you've ever had, and you're curious about how it might scale to something that's a 100, a 1,000 times bigger."
          },
          "task": {
            "type": "string",
            "description": "Task that was performed",
            "example": "transcribe"
          },
          "language": {
            "type": "string",
            "description": "Detected language of the input audio",
            "example": "english"
          },
          "duration": {
            "type": "number",
            "description": "Duration of the input audio in seconds",
            "example": 8.470000267028809
          },
          "segments": {
            "type": "array",
            "description": "Segments of the transcribed text and their corresponding details",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "integer",
                  "description": "Unique identifier of the segment"
                },
                "seek": {
                  "type": "integer",
                  "description": "Seek offset of the segment"
                },
                "start": {
                  "type": "number",
                  "description": "Start time of the segment in seconds"
                },
                "end": {
                  "type": "number",
                  "description": "End time of the segment in seconds"
                },
                "text": {
                  "type": "string",
                  "description": "Text content of the segment"
                },
                "tokens": {
                  "type": "array",
                  "items": {
                    "type": "integer"
                  },
                  "description": "Array of token IDs for the text content"
                },
                "temperature": {
                  "type": "number",
                  "description": "Temperature parameter used for generating the segment"
                },
                "avg_logprob": {
                  "type": "number",
                  "description": "Average logprob of the segment"
                },
                "compression_ratio": {
                  "type": "number",
                  "description": "Compression ratio of the segment"
                },
                "no_speech_prob": {
                  "type": "number",
                  "description": "Probability of no speech in the segment"
                }
              }
            }
          },
          "words": {
            "type": "array",
            "description": "Individual words and their corresponding timestamps",
            "items": {
              "type": "object",
              "properties": {
                "word": {
                  "type": "string",
                  "description": "The text content of the word"
                },
                "start": {
                  "type": "number",
                  "description": "Start time of the word in seconds"
                },
                "end": {
                  "type": "number",
                  "description": "End time of the word in seconds"
                }
              }
            }
          }
        }
      },
      "EmbeddingRequest": {
        "type": "object",
        "required": [
          "model",
          "input"
        ],
        "properties": {
          "model": {
            "type": "string",
            "description": "Model identifier in 'provider/model' format"
          },
          "input": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              {
                "type": "array",
                "items": {
                  "type": "integer"
                }
              },
              {
                "type": "array",
                "items": {
                  "type": "array",
                  "items": {
                    "type": "integer"
                  }
                }
              }
            ],
            "description": "Input text or tokens to embed"
          },
          "encoding_format": {
            "type": "string",
            "enum": [
              "float",
              "base64"
            ],
            "description": "The format to return the embeddings in."
          },
          "dimensions": {
            "type": "integer",
            "description": "The number of dimensions the resulting output embeddings should have."
          }
        }
      },
      "SpeechVoiceInput": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "voice": {
                  "type": "string"
                },
                "weight": {
                  "type": "number"
                }
              }
            }
          }
        ]
      },
      "SpeechRequest": {
        "type": "object",
        "required": [
          "model",
          "input",
          "voice"
        ],
        "properties": {
          "model": {
            "type": "string",
            "description": "Model to use for speech synthesis in 'provider/model' format"
          },
          "input": {
            "type": "string",
            "description": "Text to convert to speech"
          },
          "voice": {
            "$ref": "#/components/schemas/SpeechVoiceInput"
          },
          "instructions": {
            "type": "string",
            "description": "Additional instructions for voice synthesis"
          },
          "response_format": {
            "type": "string",
            "description": "Audio format for the response"
          },
          "speed": {
            "type": "number",
            "description": "Speed of the generated audio"
          }
        }
      },
      "TranscriptionRequest": {
        "type": "object",
        "required": [
          "model",
          "file"
        ],
        "properties": {
          "model": {
            "type": "string",
            "description": "Model to use for transcription in 'provider/model' format"
          },
          "file": {
            "type": "string",
            "format": "binary",
            "description": "Audio file to transcribe"
          },
          "language": {
            "type": "string",
            "description": "Language of the input audio"
          },
          "prompt": {
            "type": "string",
            "description": "Optional text to guide the model's style or continue a previous audio segment"
          },
          "response_format": {
            "type": "string",
            "description": "Format of the transcript output"
          },
          "file_format": {
            "type": "string",
            "description": "The format of the audio file"
          }
        }
      },
      "ResponsesMessage": {
        "type": "object",
        "required": [
          "role",
          "content"
        ],
        "properties": {
          "role": {
            "$ref": "#/components/schemas/MessageRole"
          },
          "content": {
            "$ref": "#/components/schemas/ResponsesMessageContent"
          }
        }
      },
      "ResponsesMessageContent": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResponsesContentBlock"
            }
          }
        ]
      },
      "ResponsesContentBlock": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/ResponsesTextBlock"
          },
          {
            "$ref": "#/components/schemas/ResponsesToolCallBlock"
          },
          {
            "$ref": "#/components/schemas/ResponsesToolOutputBlock"
          },
          {
            "$ref": "#/components/schemas/ResponsesImageBlock"
          },
          {
            "$ref": "#/components/schemas/ResponsesAudioBlock"
          },
          {
            "$ref": "#/components/schemas/ResponsesVideoBlock"
          }
        ]
      },
      "ResponsesTextBlock": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "text"
            ]
          },
          "text": {
            "type": "string"
          }
        }
      },
      "ResponsesToolCallBlock": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "tool_code",
              "tool_file_search",
              "tool_web_search",
              "tool_function"
            ]
          },
          "tool_code": {
            "$ref": "#/components/schemas/ResponsesToolCode"
          },
          "tool_file_search": {
            "$ref": "#/components/schemas/ResponsesToolFileSearch"
          },
          "tool_web_search": {
            "$ref": "#/components/schemas/ResponsesToolWebSearch"
          },
          "tool_function": {
            "$ref": "#/components/schemas/ResponsesToolFunction"
          }
        }
      },
      "ResponsesToolCode": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string"
          },
          "language": {
            "type": "string"
          }
        }
      },
      "ResponsesToolFileSearch": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string"
          },
          "filter": {
            "$ref": "#/components/schemas/ResponsesToolFileSearchFilter"
          }
        }
      },
      "ResponsesToolFileSearchFilter": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        ]
      },
      "ResponsesToolWebSearch": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string"
          }
        }
      },
      "ResponsesToolFunction": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "arguments": {
            "type": "object",
            "additionalProperties": true
          }
        }
      },
      "ResponsesToolOutputBlock": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "tool_code",
              "tool_file_search",
              "tool_web_search",
              "tool_function"
            ]
          },
          "tool_code": {
            "$ref": "#/components/schemas/ResponsesToolCodeOutput"
          },
          "tool_file_search": {
            "$ref": "#/components/schemas/ResponsesToolFileSearchOutput"
          },
          "tool_web_search": {
            "$ref": "#/components/schemas/ResponsesToolWebSearchOutput"
          },
          "tool_function": {
            "$ref": "#/components/schemas/ResponsesToolFunctionOutput"
          }
        }
      },
      "ResponsesToolCodeOutput": {
        "type": "object",
        "properties": {
          "output": {
            "type": "string"
          }
        }
      },
      "ResponsesToolFileSearchOutput": {
        "type": "object",
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "file": {
                  "type": "string"
                },
                "score": {
                  "type": "number"
                }
              }
            }
          }
        }
      },
      "ResponsesToolWebSearchOutput": {
        "type": "object",
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "url": {
                  "type": "string"
                },
                "score": {
                  "type": "number"
                }
              }
            }
          }
        }
      },
      "ResponsesFunctionToolCallOutput": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "object",
            "additionalProperties": true
          }
        ]
      },
      "ResponsesToolFunctionOutput": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "output": {
            "$ref": "#/components/schemas/ResponsesFunctionToolCallOutput"
          }
        }
      },
      "ResponsesImageBlock": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "image"
            ]
          },
          "source": {
            "$ref": "#/components/schemas/ResponsesImageSource"
          }
        }
      },
      "ResponsesImageSource": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "base64",
              "url"
            ]
          },
          "media_type": {
            "type": "string"
          },
          "data": {
            "type": "string"
          },
          "url": {
            "type": "string"
          }
        }
      },
      "ResponsesAudioBlock": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "audio"
            ]
          },
          "source": {
            "$ref": "#/components/schemas/ResponsesAudioSource"
          }
        }
      },
      "ResponsesAudioSource": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "base64",
              "url"
            ]
          },
          "media_type": {
            "type": "string"
          },
          "data": {
            "type": "string"
          },
          "url": {
            "type": "string"
          }
        }
      },
      "ResponsesVideoBlock": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "video"
            ]
          },
          "source": {
            "$ref": "#/components/schemas/ResponsesVideoSource"
          }
        }
      },
      "ResponsesVideoSource": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "base64",
              "url"
            ]
          },
          "media_type": {
            "type": "string"
          },
          "data": {
            "type": "string"
          },
          "url": {
            "type": "string"
          }
        }
      },
      "ResponsesPromptCache": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string"
          }
        }
      },
      "LLMUsage": {
        "type": "object",
        "properties": {
          "prompt_tokens": {
            "type": "integer",
            "description": "Tokens in the prompt",
            "example": 56
          },
          "completion_tokens": {
            "type": "integer",
            "description": "Tokens in the completion",
            "example": 31
          },
          "total_tokens": {
            "type": "integer",
            "description": "Total tokens used",
            "example": 87
          },
          "completion_tokens_details": {
            "$ref": "#/components/schemas/CompletionTokensDetails"
          }
        }
      },
      "CompletionTokensDetails": {
        "type": "object",
        "properties": {
          "reasoning_tokens": {
            "type": "integer",
            "description": "Tokens used for reasoning"
          },
          "audio_tokens": {
            "type": "integer",
            "description": "Tokens used for audio"
          },
          "accepted_prediction_tokens": {
            "type": "integer",
            "description": "Accepted prediction tokens"
          },
          "rejected_prediction_tokens": {
            "type": "integer",
            "description": "Rejected prediction tokens"
          }
        }
      },
      "ResponsesRequest": {
        "type": "object",
        "required": [
          "model",
          "input"
        ],
        "properties": {
          "model": {
            "type": "string",
            "description": "Model identifier in 'provider/model' format"
          },
          "input": {
            "oneOf": [
              {
                "type": "string",
                "description": "Simple text input for the response"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ResponsesMessage"
                },
                "description": "Array of ResponsesMessage objects for structured input"
              }
            ]
          },
          "fallbacks": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "stream": {
            "type": "boolean"
          },
          "background": {
            "type": "boolean"
          },
          "conversation": {
            "type": "string"
          },
          "include": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "instructions": {
            "type": "string"
          },
          "max_output_tokens": {
            "type": "integer"
          },
          "max_tool_calls": {
            "type": "integer"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true
          },
          "parallel_tool_calls": {
            "type": "boolean"
          },
          "previous_response_id": {
            "type": "string"
          },
          "prompt_cache_key": {
            "type": "string"
          },
          "reasoning": {
            "$ref": "#/components/schemas/ResponsesParametersReasoning"
          },
          "safety_identifier": {
            "type": "string"
          },
          "service_tier": {
            "type": "string"
          },
          "stream_options": {
            "$ref": "#/components/schemas/ResponsesStreamOptions"
          },
          "store": {
            "type": "boolean"
          },
          "temperature": {
            "type": "number"
          },
          "text": {
            "$ref": "#/components/schemas/ResponsesTextConfig"
          },
          "top_logprobs": {
            "type": "integer"
          },
          "top_p": {
            "type": "number"
          },
          "tool_choice": {
            "$ref": "#/components/schemas/ResponsesToolChoice"
          },
          "tools": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResponsesTool"
            }
          },
          "truncation": {
            "type": "string"
          }
        }
      },
      "ResponsesParametersReasoning": {
        "type": "object",
        "properties": {
          "effort": {
            "type": "string"
          }
        }
      },
      "ResponsesStreamOptions": {
        "type": "object",
        "properties": {
          "include_usage": {
            "type": "boolean"
          }
        }
      },
      "ResponsesTextConfig": {
        "type": "object",
        "properties": {
          "max_tokens": {
            "type": "integer"
          }
        }
      },
      "ResponsesToolChoice": {
        "oneOf": [
          {
            "type": "string",
            "enum": [
              "auto",
              "any",
              "none",
              "required",
              "tool"
            ]
          },
          {
            "$ref": "#/components/schemas/ResponsesTool"
          }
        ]
      },
      "ResponsesTool": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "function",
              "code_interpreter",
              "file_search",
              "web_search"
            ]
          },
          "function": {
            "$ref": "#/components/schemas/ResponsesToolFunction"
          }
        }
      },
      "BifrostStreamEvent": {
        "type": "object",
        "properties": {
          "BifrostResponse": {
            "$ref": "#/components/schemas/BifrostResponse"
          },
          "BifrostError": {
            "$ref": "#/components/schemas/BifrostError"
          }
        }
      },
      "Plugin": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "enabled": {
            "type": "boolean"
          },
          "config": {
            "type": "object",
            "additionalProperties": true
          }
        }
      },
      "CreatePluginRequest": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "enabled": {
            "type": "boolean"
          },
          "config": {
            "type": "object",
            "additionalProperties": true
          }
        }
      },
      "UpdatePluginRequest": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          },
          "config": {
            "type": "object",
            "additionalProperties": true
          }
        }
      },
      "VirtualKey": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "value": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "team_id": {
            "type": "string"
          },
          "customer_id": {
            "type": "string"
          },
          "is_active": {
            "type": "boolean"
          },
          "keys": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Key"
            }
          },
          "budget": {
            "$ref": "#/components/schemas/Budget"
          },
          "rate_limit": {
            "$ref": "#/components/schemas/RateLimit"
          },
          "provider_configs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VirtualKeyProviderConfig"
            }
          }
        }
      },
      "VirtualKeyProviderConfig": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Not to be provided when creating a new provider config"
          },
          "provider": {
            "type": "string",
            "description": "Provider name"
          },
          "weight": {
            "type": "number",
            "description": "Weight of the provider (0.0 to 1.0)"
          },
          "allowed_models": {
            "type": "array",
            "items": {
              "type": "string",
              "description": "Model name"
            }
          }
        }
      },
      "VirtualKeyMCPConfig": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Not to be provided when creating a new MCP config"
          },
          "mcp_client_name": {
            "type": "string",
            "description": "Name of the MCP client"
          },
          "tools_to_execute": {
            "type": "array",
            "items": {
              "type": "string",
              "description": "Tool name"
            },
            "description": "Tools to execute"
          }
        },
        "required": [
          "mcp_client_name",
          "tools_to_execute"
        ]
      },
      "Team": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "customer_id": {
            "type": "string"
          },
          "budget": {
            "$ref": "#/components/schemas/Budget"
          }
        }
      },
      "Customer": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "budget": {
            "$ref": "#/components/schemas/Budget"
          }
        }
      },
      "Budget": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "max_limit": {
            "type": "number"
          },
          "reset_duration": {
            "type": "string"
          },
          "last_reset": {
            "type": "string",
            "format": "date-time"
          },
          "current_usage": {
            "type": "number"
          }
        }
      },
      "RateLimit": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "token_max_limit": {
            "type": "integer"
          },
          "token_reset_duration": {
            "type": "string"
          },
          "request_max_limit": {
            "type": "integer"
          },
          "request_reset_duration": {
            "type": "string"
          },
          "token_last_reset": {
            "type": "string",
            "format": "date-time"
          },
          "request_last_reset": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "CreateVirtualKeyRequest": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "provider_configs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VirtualKeyProviderConfig"
            }
          },
          "mcp_configs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VirtualKeyMCPConfig"
            }
          },
          "team_id": {
            "type": "string"
          },
          "customer_id": {
            "type": "string"
          },
          "budget": {
            "$ref": "#/components/schemas/CreateBudgetRequest"
          },
          "rate_limit": {
            "$ref": "#/components/schemas/CreateRateLimitRequest"
          },
          "key_ids": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "is_active": {
            "type": "boolean"
          }
        }
      },
      "UpdateVirtualKeyRequest": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string"
          },
          "provider_configs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VirtualKeyProviderConfig"
            }
          },
          "mcp_configs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VirtualKeyMCPConfig"
            }
          },
          "team_id": {
            "type": "string"
          },
          "customer_id": {
            "type": "string"
          },
          "budget": {
            "$ref": "#/components/schemas/UpdateBudgetRequest"
          },
          "rate_limit": {
            "$ref": "#/components/schemas/UpdateRateLimitRequest"
          },
          "key_ids": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "is_active": {
            "type": "boolean"
          }
        }
      },
      "CreateBudgetRequest": {
        "type": "object",
        "properties": {
          "max_limit": {
            "type": "number"
          },
          "reset_duration": {
            "type": "string"
          }
        }
      },
      "UpdateBudgetRequest": {
        "type": "object",
        "properties": {
          "max_limit": {
            "type": "number"
          },
          "reset_duration": {
            "type": "string"
          }
        }
      },
      "CreateRateLimitRequest": {
        "type": "object",
        "properties": {
          "token_max_limit": {
            "type": "integer"
          },
          "token_reset_duration": {
            "type": "string"
          },
          "request_max_limit": {
            "type": "integer"
          },
          "request_reset_duration": {
            "type": "string"
          }
        }
      },
      "UpdateRateLimitRequest": {
        "type": "object",
        "properties": {
          "token_max_limit": {
            "type": "integer"
          },
          "token_reset_duration": {
            "type": "string"
          },
          "request_max_limit": {
            "type": "integer"
          },
          "request_reset_duration": {
            "type": "string"
          }
        }
      },
      "CreateTeamRequest": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "customer_id": {
            "type": "string"
          },
          "budget": {
            "$ref": "#/components/schemas/CreateBudgetRequest"
          }
        }
      },
      "UpdateTeamRequest": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "customer_id": {
            "type": "string"
          },
          "budget": {
            "$ref": "#/components/schemas/UpdateBudgetRequest"
          }
        }
      },
      "CreateCustomerRequest": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "budget": {
            "$ref": "#/components/schemas/CreateBudgetRequest"
          }
        }
      },
      "UpdateCustomerRequest": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "budget": {
            "$ref": "#/components/schemas/UpdateBudgetRequest"
          }
        }
      },
      "BifrostStream": {
        "type": "string",
        "description": "Server-Sent Events stream of Bifrost responses."
      },
      "ProviderResponse": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/ModelProvider"
          },
          "keys": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Key"
            },
            "description": "API keys for the provider"
          },
          "network_config": {
            "$ref": "#/components/schemas/NetworkConfig"
          },
          "concurrency_and_buffer_size": {
            "$ref": "#/components/schemas/ConcurrencyAndBufferSize"
          },
          "proxy_config": {
            "$ref": "#/components/schemas/ProxyConfig"
          },
          "send_back_raw_response": {
            "type": "boolean",
            "description": "Include raw provider response in BifrostResponse"
          },
          "custom_provider_config": {
            "$ref": "#/components/schemas/CustomProviderConfig"
          }
        }
      },
      "ListProvidersResponse": {
        "type": "object",
        "properties": {
          "providers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ProviderResponse"
            }
          },
          "total": {
            "type": "integer"
          }
        }
      },
      "AddProviderRequest": {
        "type": "object",
        "properties": {
          "provider": {
            "$ref": "#/components/schemas/ModelProvider"
          },
          "keys": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Key"
            },
            "description": "API keys for the provider"
          },
          "network_config": {
            "$ref": "#/components/schemas/NetworkConfig"
          },
          "concurrency_and_buffer_size": {
            "$ref": "#/components/schemas/ConcurrencyAndBufferSize"
          },
          "proxy_config": {
            "$ref": "#/components/schemas/ProxyConfig"
          },
          "send_back_raw_response": {
            "type": "boolean",
            "description": "Include raw provider response in BifrostResponse"
          },
          "custom_provider_config": {
            "$ref": "#/components/schemas/CustomProviderConfig"
          }
        }
      },
      "UpdateProviderRequest": {
        "type": "object",
        "properties": {
          "keys": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Key"
            },
            "description": "API keys for the provider"
          },
          "network_config": {
            "$ref": "#/components/schemas/NetworkConfig"
          },
          "concurrency_and_buffer_size": {
            "$ref": "#/components/schemas/ConcurrencyAndBufferSize"
          },
          "proxy_config": {
            "$ref": "#/components/schemas/ProxyConfig"
          },
          "send_back_raw_response": {
            "type": "boolean",
            "description": "Include raw provider response in BifrostResponse"
          },
          "custom_provider_config": {
            "$ref": "#/components/schemas/CustomProviderConfig"
          }
        }
      },
      "Log": {
        "type": "object",
        "properties": {
          "id": { "type": "string" },
          "parent_request_id": { "type": "string", "nullable": true },
          "timestamp": { "type": "string", "format": "date-time" },
          "object": { "type": "string" },
          "provider": { "type": "string" },
          "model": { "type": "string" },
          "latency": { "type": "number", "format": "double", "nullable": true },
          "cost": { "type": "number", "format": "double", "nullable": true },
          "status": { "type": "string" },
          "stream": { "type": "boolean" },
          "raw_response": { "type": "string" },
          "created_at": { "type": "string", "format": "date-time" },
          "input_history": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/ChatMessage" }
          },
          "output_message": {
            "type": "object",
            "$ref": "#/components/schemas/ChatMessage",
            "nullable": true
          },
          "responses_output": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/ResponsesMessage" }
          },
          "embedding_output": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/EmbeddingData" }
          },
          "params": { "type": "object", "nullable": true },
          "tools": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/ChatTool" }
          },
          "tool_calls": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/ChatAssistantMessageToolCall" }
          },
          "token_usage": {
            "type": "object",
            "$ref": "#/components/schemas/BifrostLLMUsage",
            "nullable": true
          },
          "error_details": {
            "type": "object",
            "$ref": "#/components/schemas/BifrostError",
            "nullable": true
          },
          "speech_input": {
            "type": "object",
            "$ref": "#/components/schemas/SpeechInput",
            "nullable": true
          },
          "transcription_input": {
            "type": "object",
            "$ref": "#/components/schemas/TranscriptionInput",
            "nullable": true
          },
          "speech_output": {
            "type": "object",
            "$ref": "#/components/schemas/BifrostSpeechResponse",
            "nullable": true
          },
          "transcription_output": {
            "type": "object",
            "$ref": "#/components/schemas/BifrostTranscriptionResponse",
            "nullable": true
          },
          "cache_debug": {
            "type": "object",
            "$ref": "#/components/schemas/BifrostCacheDebug",
            "nullable": true
          }
        }
      },
      "EmbeddingData": {
        "type": "object",
        "properties": {
          "index": { "type": "integer" },
          "object": { "type": "string", "example": "embedding" },
          "embedding": { "$ref": "#/components/schemas/EmbeddingStruct" }
        }
      },
      "EmbeddingStruct": {
        "oneOf": [
          { "type": "string" },
          { "type": "array", "items": { "type": "number", "format": "float" } },
          { "type": "array", "items": { "type": "array", "items": { "type": "number", "format": "float" } } }
        ],
        "description": "The embedding vector, which can be a string, a list of floats, or a list of lists of floats."
      },
      "BifrostLLMUsage": {
        "type": "object",
        "properties": {
          "prompt_tokens": { "type": "integer" },
          "completion_tokens": { "type": "integer" },
          "total_tokens": { "type": "integer" }
        }
      },
      "SpeechInput": {
        "type": "object",
        "properties": {
          "input": { "type": "string" }
        }
      },
      "TranscriptionInput": {
        "type": "object",
        "properties": {
          "file": {
            "type": "string",
            "format": "byte",
            "description": "The audio file to transcribe."
          }
        }
      },
      "BifrostSpeechResponse": {
        "type": "object",
        "properties": {
          "audio": { "type": "string", "format": "byte", "description": "The generated audio file." },
          "usage": { "$ref": "#/components/schemas/SpeechUsage", "nullable": true }
        }
      },
      "SpeechUsage": {
        "type": "object",
        "properties": {
          "input_tokens": { "type": "integer" },
          "output_tokens": { "type": "integer" },
          "total_tokens": { "type": "integer" }
        }
      },
      "BifrostTranscriptionResponse": {
        "type": "object",
        "properties": {
          "duration": { "type": "number", "format": "double", "nullable": true },
          "language": { "type": "string", "nullable": true },
          "text": { "type": "string" },
          "words": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/TranscriptionWord" }
          },
          "segments": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/TranscriptionSegment" }
          }
        }
      },
      "TranscriptionWord": {
        "type": "object",
        "properties": {
          "word": { "type": "string" },
          "start": { "type": "number", "format": "double" },
          "end": { "type": "number", "format": "double" }
        }
      },
      "TranscriptionSegment": {
        "type": "object",
        "properties": {
          "id": { "type": "integer" },
          "seek": { "type": "integer" },
          "start": { "type": "number", "format": "double" },
          "end": { "type": "number", "format": "double" },
          "text": { "type": "string" },
          "tokens": { "type": "array", "items": { "type": "integer" } },
          "temperature": { "type": "number", "format": "float" },
          "avg_logprob": { "type": "number", "format": "double" },
          "compression_ratio": { "type": "number", "format": "double" },
          "no_speech_prob": { "type": "number", "format": "double" }
        }
      },
      "BifrostCacheDebug": {
        "type": "object",
        "properties": {
          "cache_hit": { "type": "boolean" },
          "cache_id": { "type": "string", "nullable": true },
          "hit_type": { "type": "string", "nullable": true },
          "provider_used": { "type": "string", "nullable": true },
          "model_used": { "type": "string", "nullable": true },
          "input_tokens": { "type": "integer", "nullable": true },
          "threshold": { "type": "number", "format": "double", "nullable": true },
          "similarity": { "type": "number", "format": "double", "nullable": true }
        }
      },
      "LogSearchResult": {
        "type": "object",
        "properties": {
          "logs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Log"
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "limit": { "type": "integer" },
              "offset": { "type": "integer" },
              "sort_by": { "type": "string" },
              "order": { "type": "string" }
            }
          },
          "stats": {
            "type": "object",
            "properties": {
              "total_requests": { "type": "integer", "format": "int64" },
              "success_rate": { "type": "number", "format": "double" },
              "average_latency": { "type": "number", "format": "double" },
              "total_tokens": { "type": "integer", "format": "int64" },
              "total_cost": { "type": "number", "format": "double" }
            }
          }
        }
      },
      "ChatAssistantMessageToolCallFunction": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "arguments": {
            "type": "string",
            "description": "Stringified JSON arguments for the function call."
          }
        },
        "required": [
          "name",
          "arguments"
        ]
      },
      "ChatAssistantMessageToolCall": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "example": "function"
          },
          "id": {
            "type": "string"
          },
          "function": {
            "$ref": "#/components/schemas/ChatAssistantMessageToolCallFunction"
          }
        },
        "required": [
          "function"
        ]
      },
      "ToolFunctionParameters": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "example": "object"
          },
          "description": {
            "type": "string"
          },
          "required": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "properties": {
            "type": "object",
            "additionalProperties": true
          },
          "enum": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "additionalProperties": {
            "type": "boolean"
          }
        },
        "required": [
          "type"
        ]
      },
      "ChatToolFunction": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "parameters": {
            "$ref": "#/components/schemas/ToolFunctionParameters"
          },
          "strict": {
            "type": "boolean"
          }
        },
        "required": [
          "name"
        ]
      },
      "ChatMessageRole": {
        "type": "string",
        "enum": [
          "assistant",
          "user",
          "system",
          "tool",
          "developer"
        ]
      },
      "PaginationOptions": {
        "type": "object",
        "properties": {
          "limit": {
            "type": "integer"
          },
          "offset": {
            "type": "integer"
          },
          "sort_by": {
            "type": "string"
          },
          "order": {
            "type": "string"
          }
        }
      },
      "SearchStats": {
        "type": "object",
        "properties": {
          "total_requests": {
            "type": "integer",
            "format": "int64"
          },
          "success_rate": {
            "type": "number",
            "format": "double"
          },
          "average_latency": {
            "type": "number",
            "format": "double"
          },
          "total_tokens": {
            "type": "integer",
            "format": "int64"
          },
          "total_cost": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "SearchResult": {
        "type": "object",
        "properties": {
          "logs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Log"
            }
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationOptions"
          },
          "stats": {
            "$ref": "#/components/schemas/SearchStats"
          }
        }
      },
      "ListModelsResponse": {
        "type": "object",
        "required": [
          "data"
        ],
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ModelInfo"
            },
            "description": "Array of model information objects"
          },
          "next_page_token": {
            "type": "string",
            "description": "Token to retrieve the next page of results. Omitted if there are no more pages.",
            "example": "eyJwYWdlIjoxfQ=="
          },
          "extra_fields": {
            "type": "object",
            "properties": {
              "provider": {
                "$ref": "#/components/schemas/ModelProvider"
              },
              "request_type": {
                "$ref": "#/components/schemas/RequestType"
              },
              "latency": {
                "type": "number",
                "description": "Request latency in milliseconds",
                "example": 1234
              },
              "raw_response": {
                "type": "object",
                "description": "Raw provider response"
              }
            }
          }
        }
      },
      "ModelInfo": {
        "type": "object",
        "description": "Model information object. Only fields returned by the provider API are included; unset fields are omitted from the JSON response.",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique model identifier",
            "example": "openrouter/openai/gpt-4o"
          },
          "canonical_slug": {
            "type": "string",
            "description": "Canonical slug for the model",
            "example": "openai/gpt-4o",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Human-readable model name",
            "example": "OpenAI: GPT-4o"
          },
          "created": {
            "type": "integer",
            "description": "Unix timestamp of model creation",
            "example": 1715558400,
            "nullable": true
          },
          "context_length": {
            "type": "integer",
            "description": "Maximum context length in tokens",
            "example": 128000,
            "nullable": true
          },
          "architecture": {
            "$ref": "#/components/schemas/ModelArchitecture",
            "description": "Object describing the model's technical capabilities",
            "nullable": true
          },
          "pricing": {
            "$ref": "#/components/schemas/ModelPricing",
            "description": "Lowest price structure for using this model (all values in USD per token/request/unit)",
            "nullable": true
          },
          "top_provider": {
            "$ref": "#/components/schemas/ModelTopProvider",
            "description": "Configuration details for the primary provider",
            "nullable": true
          },
          "per_request_limits": {
            "description": "Rate limiting information (null if no limits)",
            "$ref": "#/components/schemas/ModelPerRequestLimits",
            "nullable": true
          },
          "supported_parameters": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of supported parameter names",
            "nullable": true
          },
          "default_parameters": {
            "$ref": "#/components/schemas/ModelDefaultParameters",
            "nullable": true
          },
          "hugging_face_id": {
            "type": "string",
            "description": "Hugging Face model identifier",
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "Description of the model and its capabilities",
            "example": "GPT-4o (\"o\" for \"omni\") is OpenAI's latest AI model, supporting both text and image inputs with text outputs",
            "nullable": true
          },
          "owned_by": {
            "type": "string",
            "description": "Organization that owns the model",
            "example": "openai",
            "nullable": true
          },
          "supported_methods": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of supported API methods",
            "nullable": true
          }
        }
      },
      "ModelArchitecture": {
        "type": "object",
        "properties": {
          "tokenizer": {
            "type": "string",
            "example": "GPT",
            "description": "Tokenization method used by the model"
          },
          "instruct_type": {
            "description": "Instruction format type (null if not applicable)",
            "type": "string",
            "nullable": true
          },
          "input_modalities": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": ["file", "image", "text", "audio", "video"]
            },
            "example": ["text", "image", "file"],
            "description": "Supported input types for the model"
          },
          "output_modalities": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": ["text", "image", "audio", "video"]
            },
            "example": ["text"],
            "description": "Supported output types for the model"
          },
          "modality": {
            "type": "string",
            "description": "Primary model modality",
            "example": "text+image->text"
          }
        }
      },
      "ModelPricing": {
        "type": "object",
        "description": "All pricing values are in USD per token/request/unit. A value of '0' indicates the feature is free.",
        "properties": {
          "prompt": {
            "type": "string",
            "description": "Cost per input token in USD",
            "example": "0.0000025"
          },
          "completion": {
            "type": "string",
            "description": "Cost per output token in USD",
            "example": "0.00001"
          },
          "request": {
            "type": "string",
            "description": "Fixed cost per API request in USD",
            "example": "0"
          },
          "image": {
            "type": "string",
            "description": "Cost per image input in USD",
            "example": "0.003613"
          },
          "web_search": {
            "type": "string",
            "description": "Cost per web search operation in USD",
            "example": "0"
          },
          "internal_reasoning": {
            "type": "string",
            "description": "Cost for internal reasoning tokens in USD",
            "example": "0"
          },
          "input_cache_read": {
            "type": "string",
            "description": "Cost per cached input token read in USD",
            "example": "0.00000125"
          },
          "input_cache_write": {
            "type": "string",
            "description": "Cost per cached input token write in USD",
            "example": "0"
          }
        }
      },
      "ModelTopProvider": {
        "type": "object",
        "description": "Configuration details for the primary provider",
        "properties": {
          "context_length": {
            "type": "integer",
            "description": "Provider-specific context limit in tokens"
          },
          "max_completion_tokens": {
            "type": "integer",
            "description": "Maximum completion tokens"
          },
          "is_moderated": {
            "type": "boolean",
            "description": "Whether content moderation is applied to the model output"
          }
        }
      },
      "ModelPerRequestLimits": {
        "type": "object",
        "properties": {
          "prompt_tokens": {
            "type": "integer",
            "description": "Maximum prompt tokens per request"
          },
          "completion_tokens": {
            "type": "integer",
            "description": "Maximum completion tokens per request"
          }
        }
      },
      "ModelDefaultParameters": {
        "type": "object"
      }
    },
    "responses": {
      "BadRequest": {
        "description": "Bad Request - Invalid request format or missing required fields",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/BifrostError"
            },
            "example": {
              "is_bifrost_error": true,
              "status_code": 400,
              "error": {
                "type": "invalid_request_error",
                "message": "Invalid request format"
              }
            }
          }
        }
      },
      "Unauthorized": {
        "description": "Unauthorized - Invalid or missing API key",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/BifrostError"
            },
            "example": {
              "is_bifrost_error": true,
              "status_code": 401,
              "error": {
                "type": "authentication_error",
                "message": "Invalid API key provided"
              }
            }
          }
        }
      },
      "RateLimited": {
        "description": "Rate Limited - Too many requests",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/BifrostError"
            },
            "example": {
              "is_bifrost_error": true,
              "status_code": 429,
              "error": {
                "type": "rate_limit_error",
                "message": "Rate limit exceeded"
              }
            }
          }
        }
      },
      "InternalServerError": {
        "description": "Internal Server Error - An unexpected error occurred",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/BifrostError"
            },
            "example": {
              "is_bifrost_error": true,
              "status_code": 500,
              "error": {
                "type": "api_error",
                "message": "Internal server error occurred"
              }
            }
          }
        }
      }
    }
  }
}