---
title: "Semantic Caching"
description: "Intelligent response caching based on semantic similarity. Reduce costs and latency by serving cached responses for semantically similar requests."
icon: "database"
---

## Overview

Semantic caching uses vector similarity search to intelligently cache AI responses, serving cached results for semantically similar requests even when the exact wording differs. This dramatically reduces API costs and latency for repeated or similar queries.

**Key Benefits:**
- **Cost Reduction**: Avoid expensive LLM API calls for similar requests
- **Improved Performance**: Sub-millisecond cache retrieval vs multi-second API calls  
- **Intelligent Matching**: Semantic similarity beyond exact text matching
- **Streaming Support**: Full streaming response caching with proper chunk ordering

---

## Core Features

- **Dual-Layer Caching**: Exact hash matching + semantic similarity search (customizable threshold)
- **Vector-Powered Intelligence**: Uses embeddings to find semantically similar requests
- **Dynamic Configuration**: Per-request TTL and threshold overrides via headers/context
- **Model/Provider Isolation**: Separate caching per model and provider combination

---

## Vector Store Setup

<Tabs group="vector-store-setup">

<Tab title="Go SDK">

```go
import (
    "context"
    "github.com/maximhq/bifrost/framework/vectorstore"
    "github.com/maximhq/bifrost/core/schemas"
)

// Configure vector store
vectorConfig := &vectorstore.Config{
    Enabled: true,
    Type:    vectorstore.VectorStoreTypeWeaviate,
    Config: vectorstore.WeaviateConfig{
        Scheme:    "http",
        Host:      "localhost:8080",
    },
}

// Create vector store
store, err := vectorstore.NewVectorStore(context.Background(), vectorConfig, logger)
if err != nil {
    log.Fatal("Failed to create vector store:", err)
}
```

</Tab>

<Tab title="config.json">

```json
{
  "vector_store": {
    "enabled": true,
    "type": "weaviate",
    "config": {
      "host": "localhost:8080",
      "scheme": "http",
    }
  }
}
```

**For Weaviate Cloud:**
```json
{
  "vector_store": {
    "enabled": true,
    "type": "weaviate",
    "config": {
      "host": "your-cluster.weaviate.network",
      "scheme": "https",
      "api_key": "your-weaviate-api-key"
    }
  }
}
```

</Tab>

</Tabs>

---

## Semantic Cache Configuration

<Tabs group="cache-config">

<Tab title="Go SDK">

```go
import (
    "github.com/maximhq/bifrost/plugins/semanticcache"
    "github.com/maximhq/bifrost/core/schemas"
)

// Configure semantic cache plugin
cacheConfig := semanticcache.Config{
    CacheKey:    "request-cache-key",     // Required: bifrost will look for this key in ctx for cache triggering
    CacheTTLKey: "request-cache-ttl",     // Optional: bifrost will look for this key in ctx for TTL override
    CacheThresholdKey: "request-cache-threshold", // Optional: bifrost will look for this key in ctx for threshold override
    
    // Embedding model configuration
    Provider:       schemas.OpenAI,
    Keys:          []schemas.Key{{Value: "sk-..."}},
    EmbeddingModel: "text-embedding-3-small", // Optional: defaults to provider default
    
    // Cache behavior
    TTL:       5 * time.Minute,  // Default TTL: 5 minutes
    Threshold: 0.8,              // Similarity threshold: 0.8 (80%)
    
    // Advanced options
    CacheByModel:    bifrost.Ptr(true),  // Include model in cache key (default: true)
    CacheByProvider: bifrost.Ptr(true),  // Include provider in cache key (default: true)
}

// Create plugin
plugin, err := semanticcache.Init(context.Background(), cacheConfig, logger, store)
if err != nil {
    log.Fatal("Failed to create semantic cache plugin:", err)
}

// Add to Bifrost config
bifrostConfig := schemas.BifrostConfig{
    Plugins: []schemas.Plugin{plugin},
    // ... other config
}
```

</Tab>

<Tab title="config.json">

```json
{
  "plugins": [
    {
      "enabled": true,
      "name": "semantic_cache",
      "config": {        
        "provider": "openai",
        "embedding_model": "text-embedding-3-small",
        
        "ttl": "5m",
        "threshold": 0.8,
        
        "cache_by_model": true,
        "cache_by_provider": true
      }
    }
  ]
}
```

**Note**: All the available keys will be taken from the provider config on initialization, so make sure to add the keys to the provider you have specified in the config. Any updates to the keys will not be reflected until next restart.

**TTL Format Options:**
- Duration strings: `"30s"`, `"5m"`, `"1h"`, `"24h"`
- Numeric seconds: `300` (5 minutes), `3600` (1 hour)

</Tab>

</Tabs>

---

## Cache Triggering

<Warning>
**Cache Key is mandatory**: Semantic caching only activates when a cache key is provided. Without a cache key, requests bypass caching entirely.
</Warning>

<Tabs group="cache-triggering">

<Tab title="Go SDK">
Must set cache key in request context:

```go
// This request WILL be cached
ctx = context.WithValue(ctx, semanticcache.ContextKey("request-cache-key"), "session-123")
response, err := client.ChatCompletionRequest(ctx, request)

// This request will NOT be cached (no context value)
response, err := client.ChatCompletionRequest(context.Background(), request)
```

</Tab>

<Tab title="HTTP API">
Must set cache key in request header `x-bf-cache-key`:

```bash
# This request WILL be cached
curl -H "x-bf-cache-key: session-123" ...

# This request will NOT be cached (no header)
curl ...
```

</Tab>

</Tabs>

## Per-Request Overrides

Override default TTL and similarity threshold per request:

<Tabs group="per-request-overrides">

<Tab title="Go SDK">

You can set TTL and threshold in the request context, in the keys you configured in the plugin config:

```go
// Go SDK: Custom TTL and threshold
ctx = context.WithValue(ctx, semanticcache.ContextKey("request-cache-key"), "session-123")
ctx = context.WithValue(ctx, semanticcache.ContextKey("request-cache-ttl"), 30*time.Second)
ctx = context.WithValue(ctx, semanticcache.ContextKey("request-cache-threshold"), 0.9)
```

</Tab>

<Tab title="HTTP API">

You can set TTL and threshold in the request headers `x-bf-cache-ttl` and `x-bf-cache-threshold`:

```bash
# HTTP: Custom TTL and threshold
curl -H "x-bf-cache-key: session-123" \
     -H "x-bf-cache-ttl: 30s" \
     -H "x-bf-cache-threshold: 0.9" ...
```

</Tab>

</Tabs>

---

## Cache Management

### Cache Metadata Location

When responses are served from semantic cache, 3 key variables are automatically added to the response:

**Location**: `response.ExtraFields.CacheDebug` (as a JSON object)

**Fields**:
- `CacheHit` (boolean): `true` when response served from cache
- `CacheHitType` (string): `"semantic"` for similarity match, `"direct"` for hash match
- `CacheID` (string): Unique cache entry ID for management operations  

**Semantic Cache Only**:
- `CacheThreshold` (number): Similarity threshold used for the match
- `CacheSimilarity` (number): Similarity score for the match

Example HTTP Response:

```json
{
  "extra_fields": {
    "cache_debug": {
      "cache_hit": true,
      "cache_hit_type": "semantic",
      "cache_id": "550e8500-e29b-41d4-a725-446655440001",
      "cache_threshold": 0.8,
      "cache_similarity": 0.95
    }
  }
}
```


These variables allow you to detect cached responses and get the cache entry ID needed for clearing specific entries.

### Clear Specific Cache Entry

Use the request ID from cached responses to clear specific entries:

<Tabs group="cache-clear">

<Tab title="HTTP API">

```bash
# Clear specific cached entry by request ID
curl -X DELETE http://localhost:8080/api/cache/clear/550e8400-e29b-41d4-a716-446655440000

# Clear all entries for a cache key
curl -X DELETE http://localhost:8080/api/cache/clear-by-key/support-session-456
```

</Tab>

<Tab title="Go SDK">

```go
// Clear specific entry by request ID
err := plugin.ClearCacheForRequestID(nil, "550e8400-e29b-41d4-a716-446655440000")

// Clear all entries for a cache key  
err := plugin.ClearCacheForKey("support-session-456")
```

</Tab>

</Tabs>

---

## Use Cases

### Customer Support
Cache responses for common questions like "How do I reset my password?" or "What are your business hours?" - semantically similar variations get instant responses.

### Content Generation  
Cache blog post outlines, product descriptions, or marketing copy for similar topics, reducing costs for content teams.

### Data Analysis
Cache responses for similar analytical queries about datasets, dashboards, or reports, speeding up business intelligence workflows.

---

<Info>
**Vector Store Requirement**: Semantic caching requires a configured vector store (currently Weaviate only). Without vector store setup, the plugin will not function.
</Info>